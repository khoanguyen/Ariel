<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">RESTEasy JAX-RS</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e1"/>RESTEasy JAX-RS</h1></div><div><h2 class="subtitle">RESTFul Web Services for Java</h2></div><div><p class="releaseinfo">2.2.1.GA</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#Overview">1. Overview</a></span></dt><dt><span class="chapter"><a href="#license">2. License</a></span></dt><dt><span class="chapter"><a href="#Installation_Configuration">3. Installation/Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e56">3.1. Standalone Resteasy</a></span></dt><dt><span class="sect1"><a href="#d0e72">3.2. Configuration Switches</a></span></dt><dt><span class="sect1"><a href="#javax.ws.rs.core.Application">3.3. javax.ws.rs.core.Application</a></span></dt><dt><span class="sect1"><a href="#listener">3.4. RESTEasy as a ServletContextListener</a></span></dt><dt><span class="sect1"><a href="#filter">3.5. RESTEasy as a servlet Filter</a></span></dt><dt><span class="sect1"><a href="#d0e219">3.6. Install/Config in JBoss 6-M4 and Higher</a></span></dt><dt><span class="sect1"><a href="#RESTEasyLogging">3.7. RESTEasyLogging</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Using_Path">4. Using @Path and @GET, @POST, etc.</a></span></dt><dd><dl><dt><span class="sect1"><a href="#_Path_and_regular_expression_mappings">4.1. @Path and regular expression mappings</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_PathParam">5. @PathParam</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Advanced__PathParam_and_Regular_Expressions">5.1. Advanced @PathParam and Regular Expressions</a></span></dt><dt><span class="sect1"><a href="#_PathParam_and_PathSegment">5.2. @PathParam and PathSegment</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_QueryParam">6. @QueryParam</a></span></dt><dt><span class="chapter"><a href="#_HeaderParam">7. @HeaderParam</a></span></dt><dt><span class="chapter"><a href="#LinkHeader">8. Linking resources</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e550">8.1. Link Headers</a></span></dt><dt><span class="section"><a href="#d0e560">8.2. Atom links in the resource representations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e573">8.2.1. Configuration</a></span></dt><dt><span class="section"><a href="#d0e605">8.2.2. Your first links injected</a></span></dt><dt><span class="section"><a href="#d0e645">8.2.3. Customising how the Atom links are serialised</a></span></dt><dt><span class="section"><a href="#d0e659">8.2.4. Specifying which JAX-RS methods are tied to which resources</a></span></dt><dt><span class="section"><a href="#d0e799">8.2.5. Specifying path parameter values for URI templates</a></span></dt><dt><span class="section"><a href="#d0e986">8.2.6. Securing entities</a></span></dt><dt><span class="section"><a href="#d0e1042">8.2.7. Extending the UEL context</a></span></dt><dt><span class="section"><a href="#d0e1079">8.2.8. Resource facades</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#_MatrixParam">9. @MatrixParam</a></span></dt><dt><span class="chapter"><a href="#_CookieParam">10. @CookieParam</a></span></dt><dt><span class="chapter"><a href="#_FormParam">11. @FormParam</a></span></dt><dt><span class="chapter"><a href="#_Form">12. @Form</a></span></dt><dt><span class="chapter"><a href="#_DefaultValue">13. @DefaultValue</a></span></dt><dt><span class="chapter"><a href="#_Encoded_and_encoding">14. @Encoded and encoding</a></span></dt><dt><span class="chapter"><a href="#_Context">15. @Context</a></span></dt><dt><span class="chapter"><a href="#JAX-RS_Resource_Locators_and_Sub_Resources">16. JAX-RS Resource Locators and Sub Resources</a></span></dt><dt><span class="chapter"><a href="#JAX-RS_Content_Negotiation">17. JAX-RS Content Negotiation</a></span></dt><dd><dl><dt><span class="sect1"><a href="#media_mappings">17.1. URL-based negotiation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Content_Marshalling_Providers">18. Content Marshalling/Providers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Default_Providers_and_default_JAX-RS_Content_Marshalling">18.1. Default Providers and default JAX-RS Content Marshalling</a></span></dt><dt><span class="sect1"><a href="#Content_Marshalling_with__Provider_classes">18.2. Content Marshalling with @Provider classes</a></span></dt><dt><span class="sect1"><a href="#MessageBodyWorkers">18.3. Providers Utility Class</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Built_in_JAXB_providers">19. JAXB providers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#decorators">19.1. JAXB Decorators</a></span></dt><dt><span class="sect1"><a href="#Pluggable_JAXBContext_s_with_ContextResolvers">19.2. Pluggable JAXBContext's with ContextResolvers</a></span></dt><dt><span class="sect1"><a href="#JAXB_+_XML_provider">19.3. JAXB + XML provider</a></span></dt><dd><dl><dt><span class="sect2"><a href="#XmlHeader">19.3.1. @XmlHeader and @Stylesheet</a></span></dt></dl></dd><dt><span class="sect1"><a href="#JAXB_+_JSON_provider">19.4. JAXB + JSON provider</a></span></dt><dt><span class="sect1"><a href="#JAXB_+_FastinfoSet_provider">19.5. JAXB + FastinfoSet provider</a></span></dt><dt><span class="sect1"><a href="#JAXB_Collections">19.6. Arrays and Collections of JAXB Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#json_list">19.6.1. JSON and JAXB Collections/arrays</a></span></dt></dl></dd><dt><span class="sect1"><a href="#JAXB_Map">19.7. Maps of JAXB Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#json_map">19.7.1. JSON and JAXB maps</a></span></dt><dt><span class="sect2"><a href="#JAXB_JSON_problems">19.7.2. Possible Problems with Jettison Provider</a></span></dt></dl></dd><dt><span class="sect1"><a href="#JAXB_INTERFACES">19.8. Interfaces, Abstract Classes, and JAXB</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Atom">20. Resteasy Atom Support</a></span></dt><dd><dl><dt><span class="sect1"><a href="#resteasy_atom">20.1. Resteasy Atom API and Provider</a></span></dt><dt><span class="sect1"><a href="#jaxb_atom">20.2. Using JAXB with the Atom Provider</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Abdera">21. Atom support through Apache Abdera</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Abdera and Maven">21.1. Abdera and Maven</a></span></dt><dt><span class="sect1"><a href="#using_abdera">21.2. Using the Abdera Provider</a></span></dt></dl></dd><dt><span class="chapter"><a href="#json">22. JSON Support via Jackson</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Possible_Jackson_Problems">22.1. Possible Conflict With JAXB Provider</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Multipart">23. Multipart Providers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#MultipartInput">23.1. Input with multipart/mixed</a></span></dt><dt><span class="sect1"><a href="#multipart_list">23.2. java.util.List with multipart data</a></span></dt><dt><span class="sect1"><a href="#MultipartFormData">23.3. Input with multipart/form-data</a></span></dt><dt><span class="sect1"><a href="#multipart_map">23.4. java.util.Map with multipart/form-data</a></span></dt><dt><span class="sect1"><a href="#MultipartRelated">23.5. Input with multipart/related</a></span></dt><dt><span class="sect1"><a href="#multipart_output">23.6. Output with multipart</a></span></dt><dt><span class="sect1"><a href="#multipart_list_output">23.7. Multipart Output with java.util.List</a></span></dt><dt><span class="sect1"><a href="#multipart_formdata_output">23.8. Output with multipart/form-data</a></span></dt><dt><span class="sect1"><a href="#multipart_map_output">23.9. Multipart FormData Output with java.util.Map</a></span></dt><dt><span class="sect1"><a href="#multipart_related_output">23.10. Output with multipart/related</a></span></dt><dt><span class="sect1"><a href="#multipartform_annotation">23.11. @MultipartForm and POJOs</a></span></dt><dt><span class="sect1"><a href="#xop_with_multipart_related">23.12. XML-binary Optimized Packaging (Xop)</a></span></dt><dt><span class="sect1"><a href="#multipart_parsing_note">23.13. Note about multipart parsing and working with other frameworks</a></span></dt><dt><span class="sect1"><a href="#multipart_overwrite_default_content_type">23.14. Overwriting the default fallback content type for multipart messages</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Built_in_YAML_Provider">24. YAML Provider</a></span></dt><dt><span class="chapter"><a href="#StringConverter">25. String marshalling for String based @*Param</a></span></dt><dd><dl><dt><span class="sect1"><a href="#StringConverterInterface">25.1. StringConverter</a></span></dt><dt><span class="sect1"><a href="#StringParamUnmarshaller">25.2. StringParamUnmarshaller</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Responses_using_javax.ws.rs.core.Response">26. Responses using javax.ws.rs.core.Response</a></span></dt><dt><span class="chapter"><a href="#ExceptionHandling">27. Exception Handling</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ExceptionMappers">27.1. Exception Mappers</a></span></dt><dt><span class="sect1"><a href="#builtinException">27.2. Resteasy Built-in Internally-Thrown Exceptions</a></span></dt><dt><span class="sect1"><a href="#overring_resteasy_exceptions">27.3. Overriding Resteasy Builtin Exceptions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Configuring_Individual_JAX-RS_Resource_Beans">28. Configuring Individual JAX-RS Resource Beans</a></span></dt><dt><span class="chapter"><a href="#gzip">29. GZIP Compression/Decompression</a></span></dt><dt><span class="chapter"><a href="#Cache_NoCache_CacheControl">30. Resteasy Caching Features</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Cache_Annotation">30.1. @Cache and @NoCache Annotations</a></span></dt><dt><span class="sect1"><a href="#client_cache">30.2. Client "Browser" Cache</a></span></dt><dt><span class="sect1"><a href="#server_cache">30.3. Local Server-Side Response Cache</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Interceptors">31. Interceptors</a></span></dt><dd><dl><dt><span class="sect1"><a href="#MessageBodyInterceptors">31.1. MessageBodyReader/Writer Interceptors</a></span></dt><dt><span class="sect1"><a href="#PreProcessInterceptors">31.2. PreProcessInterceptor</a></span></dt><dt><span class="sect1"><a href="#PostProcessInterceptors">31.3. PostProcessInterceptors</a></span></dt><dt><span class="sect1"><a href="#ClientExecutionInterceptors">31.4. ClientExecutionInterceptors</a></span></dt><dt><span class="sect1"><a href="#BindingInterceptors">31.5. Binding Interceptors</a></span></dt><dt><span class="sect1"><a href="#registering">31.6. Registering Interceptors</a></span></dt><dt><span class="sect1"><a href="#interceptorPrecedence">31.7. Interceptor Ordering and Precedence</a></span></dt><dd><dl><dt><span class="sect2"><a href="#customprecedence">31.7.1. Custom Precedence</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Asynchronous_HTTP_Request_Processing">32. Asynchronous HTTP Request Processing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Asynch_HTTP_Tomcat6">32.1. Tomcat 6 and JBoss 4.2.3 Support</a></span></dt><dt><span class="sect1"><a href="#Asynch_HTTP_Servlet3">32.2. Servlet 3.0 Support</a></span></dt><dt><span class="sect1"><a href="#Asynch_HTTP_JBossWeb">32.3. JBossWeb, JBoss AS 5.0.x Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#async_job_service">33. Asynchronous Job Service</a></span></dt><dd><dl><dt><span class="sect1"><a href="#async_job">33.1. Using Async Jobs</a></span></dt><dt><span class="sect1"><a href="#oneway">33.2. Oneway: Fire and Forget</a></span></dt><dt><span class="sect1"><a href="#async_job_setup">33.3. Setup and Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#RESTEasy_Embedded_Container">34. Embedded Container</a></span></dt><dt><span class="chapter"><a href="#RESTEasy_Server-side_Mock_Framework">35. Server-side Mock Framework</a></span></dt><dt><span class="chapter"><a href="#Securing_JAX-RS_and_RESTeasy">36. Securing JAX-RS and RESTeasy</a></span></dt><dt><span class="chapter"><a href="#Authentication">37. Authentication</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2674">37.1. OAuth core 1.0a</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2694">37.1.1. Authenticating with OAuth</a></span></dt><dt><span class="section"><a href="#d0e2772">37.1.2. Accessing protected resources</a></span></dt><dt><span class="section"><a href="#d0e2815">37.1.3. Implementing an OAuthProvider</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#signature">38. Digital Signature Framework</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2934">38.1. Maven settings</a></span></dt><dt><span class="section"><a href="#d0e2942">38.2. Signing API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2953">38.2.1. @Signed annotation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2967">38.3. Signature Verification API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2983">38.3.1. Annotation-based verification</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2998">38.4. Managing Keys via a KeyRepository</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3003">38.4.1. Create a KeyStore</a></span></dt><dt><span class="section"><a href="#d0e3016">38.4.2. Configure Restreasy to use the KeyRepository</a></span></dt><dt><span class="section"><a href="#d0e3043">38.4.3. Using DNS to Discover Public Keys</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#RESTEasy_EJB_Integration">39. EJB Integration</a></span></dt><dt><span class="chapter"><a href="#RESTEasy_Spring_Integration">40. Spring Integration</a></span></dt><dt><span class="chapter"><a href="#CDI">41. CDI Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3157">41.1. Using CDI beans as JAX-RS components</a></span></dt><dt><span class="section"><a href="#d0e3172">41.2. Default scopes</a></span></dt><dt><span class="section"><a href="#d0e3193">41.3. Configuration within JBoss 6 M4 and Higher</a></span></dt><dt><span class="section"><a href="#d0e3198">41.4. Configuration with different distributions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Seam">42. Seam Integration</a></span></dt><dt><span class="chapter"><a href="#Guice1">43. Guice 2.0 Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3243">43.1. Configuring Stage</a></span></dt></dl></dd><dt><span class="chapter"><a href="#RESTEasy_Client_Framework">44. Client Framework</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Custom_client-side_responses">44.1. Abstract Responses</a></span></dt><dt><span class="sect1"><a href="#Sharing_interfaces">44.2. Sharing an interface between client and server</a></span></dt><dt><span class="sect1"><a href="#Client_error_handling">44.3. Client Error Handling</a></span></dt><dt><span class="sect1"><a href="#ClientRequest">44.4. Manual ClientRequest API</a></span></dt><dt><span class="sect1"><a href="#spring_client_proxy">44.5. Spring integration on client side</a></span></dt></dl></dd><dt><span class="chapter"><a href="#AJAX_Client">45. AJAX Client</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3371">45.1. Generated JavaScript API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3387">45.1.1. JavaScript API servlet</a></span></dt><dt><span class="section"><a href="#d0e3394">45.1.2. JavaScript API usage</a></span></dt><dt><span class="section"><a href="#d0e3515">45.1.3. MIME types and unmarshalling.</a></span></dt><dt><span class="section"><a href="#d0e3568">45.1.4. MIME types and marshalling.</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3633">45.2. Using the JavaScript API to build AJAX queries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3638">45.2.1. The REST object</a></span></dt><dt><span class="section"><a href="#d0e3679">45.2.2. The REST.Request class</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Maven_and_RESTEasy">46. Maven and RESTEasy</a></span></dt><dt><span class="chapter"><a href="#JBoss5">47. JBoss AS 5.x Integration</a></span></dt><dt><span class="chapter"><a href="#JBoss AS 6">48. JBoss AS 6 Integration</a></span></dt><dt><span class="chapter"><a href="#doc">49. Documentation Support</a></span></dt><dt><span class="chapter"><a href="#Migration_from_older_versions">50. Migration from older versions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#22_221">50.1. Migrating from 2.2.0 to 2.2.1</a></span></dt><dt><span class="sect1"><a href="#21_22">50.2. Migrating from 2.1.x to 2.2</a></span></dt><dt><span class="sect1"><a href="#20_21">50.3. Migrating from 2.0.x to 2.1</a></span></dt><dt><span class="sect1"><a href="#Migrating_to_Resteasy_12_20">50.4. Migrating from 1.2.x to 2.0</a></span></dt><dt><span class="sect1"><a href="#migrating_1.2_1.2.1">50.5. Migrating from 1.2.GA to 1.2.1.GA</a></span></dt><dt><span class="sect1"><a href="#Migrating_to_Resteasy_1_1_1_2">50.6. Migrating from 1.1 to 1.2</a></span></dt></dl></dd><dt><span class="chapter"><a href="#REST_BOOKS">51. Books You Can Read</a></span></dt></dl></div><div class="preface" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Preface</h2></div></div></div><p>
         Commercial development support, production support and training for RESTEasy JAX-RS is
         available through JBoss, a division of Red Hat Inc. (see http://www.jboss.com/).
      </p><p>
         In some of the example listings, what is meant to be displayed on one line does not fit
         inside the available page width. These lines have been broken up. A '\' at the end of a
         line means that a break has been introduced to fit in the page, with the following lines
         indented. So:
         </p><pre class="programlisting">
            Let's pretend to have an extremely \
            long line that \
            does not fit
            This one is short
         </pre><p>
         Is really:
         </p><pre class="programlisting">
            Let's pretend to have an extremely long line that does not fit
            This one is short
         </pre><p>
      </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Overview"/>Chapter 1. Overview</h2></div></div></div><p>

JAX-RS, JSR-311, is a new JCP specification that provides a Java API for RESTful Web Services over the HTTP protocol. Resteasy is an portable implementation of this specification which can run in any Servlet container. Tighter integration with JBoss Application Server is also available to make the user experience nicer in that environment. While JAX-RS is only a server-side specification, Resteasy has innovated to bring JAX-RS to the client through the RESTEasy JAX-RS Client Framework. This client-side framework allows you to map outgoing HTTP requests to remote servers using JAX-RS annotations and interface proxies.
</p><p>


</p><p>

</p><div class="itemizedlist"><ul><li>
 JAX-RS implementation
</li><li>
 Portable to any app-server/Tomcat that runs on JDK 5 or higher
</li><li>
 Embeddedable server implementation for junit testing
</li><li>
 EJB and Spring integration
</li><li>
 Client framework to make writing HTTP clients easy (JAX-RS only define server bindings)
</li></ul></div><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="license"/>Chapter 2. License</h2></div></div></div><p>RESTEasy is distributed under the ASL 2.0 license. It does not distribute any thirdparty libraries that are
        GPL. It does ship thirdparty libraries licensed under
        Apache ASL 2.0 and LGPL.
    </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Installation_Configuration"/>Chapter 3. Installation/Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#d0e56">3.1. Standalone Resteasy</a></span></dt><dt><span class="sect1"><a href="#d0e72">3.2. Configuration Switches</a></span></dt><dt><span class="sect1"><a href="#javax.ws.rs.core.Application">3.3. javax.ws.rs.core.Application</a></span></dt><dt><span class="sect1"><a href="#listener">3.4. RESTEasy as a ServletContextListener</a></span></dt><dt><span class="sect1"><a href="#filter">3.5. RESTEasy as a servlet Filter</a></span></dt><dt><span class="sect1"><a href="#d0e219">3.6. Install/Config in JBoss 6-M4 and Higher</a></span></dt><dt><span class="sect1"><a href="#RESTEasyLogging">3.7. RESTEasyLogging</a></span></dt></dl></div><p>
        RESTEasy is installed and configured in different ways depending on which environment you are running in.
        If you are running in JBoss AS 6-M4 (milestone 4) or higher, resteasy is already bundled and integrated
        completely
        so there is very little you have to do. If you are running in a different distribution, there is some manual
        installation and configuration you will have to do.

    </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e56"/>3.1. Standalone Resteasy</h2></div></div></div><p>
            If you are using resteasy outside of JBoss AS 6, you will need to do a few manual steps to install and
            configure resteasy.
            RESTeasy is deployed as a WAR archive and thus depends on a Servlet container. We strongly suggest that you
            use Maven to build your WAR files as RESTEasy is split into
            a bunch of different modules. You can see an example Maven project in one of the examples in the examples/
            directory
        </p><p>
            Also, when you download RESTeasy and unzip it you will see a lib/ directory that contains the libraries
            needed by resteasy.
            Copy these into your /WEB-INF/lib directory. Place your JAX-RS annotated class resources and providers
            within
            one or more jars within /WEB-INF/lib or your raw class files within /WEB-INF/classes.
        </p><p>
            RESTeasy is implemented as a Servlet and deployed within a WAR file. If you open up the WEB-INF/web.xml in
            one of the example projects of your RESTeasy download you will see this:
        </p><p>

            </p><pre class="programlisting">
                
&lt;web-app&gt;
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
            &lt;param-value&gt;com.restfully.shop.services.ShoppingApplication&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

            </pre><p>
        </p><p>
            The Resteasy servlet is responsible for initializing some basic components of RESTeasy.
        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e72"/>3.2. Configuration Switches</h2></div></div></div><p>Resteasy receives configuration options from &lt;context-param&gt; elements.</p><p>
            </p><div class="table"><a id="d0e79"/><p class="title"><b>Table 3.1. </b></p><div class="table-contents"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>
                                Option Name
                            </th><th>
                                Default Value
                            </th><th>
                                Description
                            </th></tr></thead><tbody><tr><td>
                                resteasy.servlet.mapping.prefix
                            </td><td>
                                no default
                            </td><td>
                                If the url-pattern for the Resteasy servlet-mapping is not /*
                            </td></tr><tr><td>
                                resteasy.scan
                            </td><td>
                                false
                            </td><td>
                                Automatically scan WEB-INF/lib jars and WEB-INF/classes directory for both @Provider and
                                JAX-RS resource classes (@Path, @GET, @POST etc..) and register them
                            </td></tr><tr><td>
                                resteasy.scan.providers
                            </td><td>
                                false
                            </td><td>
                                Scan for @Provider classes and register them
                            </td></tr><tr><td>
                                resteasy.scan.resources
                            </td><td>
                                false
                            </td><td>
                                Scan for JAX-RS resource classes
                            </td></tr><tr><td>
                                resteasy.providers
                            </td><td>
                                no default
                            </td><td>
                                A comma delimited list of fully qualified @Provider class names you want to register
                            </td></tr><tr><td>
                                resteasy.use.builtin.providers
                            </td><td>
                                true
                            </td><td>
                                Whether or not to register default, built-in @Provider classes. (Only available in
                                1.0-beta-5 and later)
                            </td></tr><tr><td>
                                resteasy.resources
                            </td><td>
                                no default
                            </td><td>
                                A comma delimited list of fully qualified JAX-RS resource class names you want to
                                register
                            </td></tr><tr><td>
                                resteasy.jndi.resources
                            </td><td>
                                no default
                            </td><td>
                                A comma delimited list of JNDI names which reference objects you want to register as
                                JAX-RS resources
                            </td></tr><tr><td>
                                javax.ws.rs.Application
                            </td><td>
                                no default
                            </td><td>
                                Fully qualified name of Application class to bootstrap in a spec portable way
                            </td></tr><tr><td>
                                resteasy.media.type.mappings
                            </td><td>
                                no default
                            </td><td>
                                Replaces the need for an Accept header by mapping file name extensions (like .xml or
                                .txt) to a media type. Used when the client
                                is unable to use a Accept header to choose a representation (i.e. a browser). See JAX-RS
                                Content Negotiation chapter for more details.
                            </td></tr><tr><td>
                                resteasy.language.mappings
                            </td><td>
                                no default
                            </td><td>
                                Replaces the need for an Accept-Language header by mapping file name extensions (like
                                .en or .fr) to a language. Used when the client
                                is unable to use a Accept-Language header to choose a language (i.e. a browser). See
                                JAX-RS Content Negotiation chapter for more details
                            </td></tr></tbody></table></div></div><p><br class="table-break"/>

        </p><p>

            The resteasy.servlet.mapping.prefix &lt;context param&gt; variable must be set if your servlet-mapping for
            the Resteasy servlet has a url-pattern other than /*. For example, if the url-pattern is
        </p><p>

            </p><pre class="programlisting">

                &lt;servlet-mapping&gt;
                &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
                &lt;url-pattern&gt;/restful-services/*&lt;/url-pattern&gt;
                &lt;/servlet-mapping&gt;
            </pre><p>
        </p><p>

            Then the value of resteasy-servlet.mapping.prefix must be:
        </p><p>

            </p><pre class="programlisting">

                &lt;context-param&gt;
                &lt;param-name&gt;resteasy.servlet.mapping.prefix&lt;/param-name&gt;
                &lt;param-value&gt;/restful-services&lt;/param-value&gt;
                &lt;/context-param&gt;
            </pre><p>
        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="javax.ws.rs.core.Application"/>3.3. javax.ws.rs.core.Application</h2></div></div></div><p>

            The javax.ws.rs.core.Application class is a standard JAX-RS class that you may implement to provide
            information on your deployment. It is simply a class the lists all JAX-RS root resources and providers.
        </p><p>

            </p><pre class="programlisting">
                /**
                * Defines the components of a JAX-RS application and supplies additional
                * metadata. A JAX-RS application or implementation supplies a concrete
                * subclass of this abstract class.
                */
                public abstract class Application
                {
                private static final Set&lt;Object&gt; emptySet = Collections.emptySet();

                /**
                * Get a set of root resource and provider classes. The default lifecycle
                * for resource class instances is per-request. The default lifecycle for
                * providers is singleton.
                * &lt;p/&gt;
                * &lt;p&gt;Implementations should warn about and ignore classes that do not
                * conform to the requirements of root resource or provider classes.
                * Implementations should warn about and ignore classes for which
                * {@link #getSingletons()} returns an instance. Implementations MUST
                * NOT modify the returned set.&lt;/p&gt;
                *
                * @return a set of root resource and provider classes. Returning null
                * is equivalent to returning an empty set.
                */
                public abstract Set&lt;Class&lt;?&gt;&gt; getClasses();

                /**
                * Get a set of root resource and provider instances. Fields and properties
                * of returned instances are injected with their declared dependencies
                * (see {@link Context}) by the runtime prior to use.
                * &lt;p/&gt;
                * &lt;p&gt;Implementations should warn about and ignore classes that do not
                * conform to the requirements of root resource or provider classes.
                * Implementations should flag an error if the returned set includes
                * more than one instance of the same class. Implementations MUST
                * NOT modify the returned set.&lt;/p&gt;
                * &lt;p/&gt;
                * &lt;p&gt;The default implementation returns an empty set.&lt;/p&gt;
                *
                * @return a set of root resource and provider instances. Returning null
                * is equivalent to returning an empty set.
                */
                public Set&lt;Object&gt; getSingletons()
                {
                return emptySet;
                }

                }
            </pre><p>
        </p><p>


        </p><p>

            To use Application you must set a servlet init-param, javax.ws.rs.Application with a fully qualified class
            that implements Application. For example:
        </p><p>

            </p><pre class="programlisting">    
    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
            &lt;param-value&gt;com.restfully.shop.services.ShoppingApplication&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;  </pre><p>
        </p><p>

            If you have this set, you should probably turn off automatic scanning as this will probably result in
            duplicate classes being registered.
        </p><p>


        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="listener"/>3.4. RESTEasy as a ServletContextListener</h2></div></div></div><p>
            The initialization of RESTEasy can be performed within a ServletContextListener instead of within the
            Servlet. You may need this if you are writing custom Listeners that need to interact with RESTEasy at boot
            time. An example of this is the RESTEasy Spring integration that requires a Spring ServletContextListener.
            The org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap class is a ServletContextListener that
            configures an instance of an ResteasyProviderFactory and Registry. You can obtain instances of a
            ResteasyProviderFactory and Registry from the ServletContext attributes
            org.jboss.resteasy.spi.ResteasyProviderFactory and org.jboss.resteasy.spi.Registry. From these instances you
            can programmatically interact with RESTEasy registration interfaces.
        </p><pre class="programlisting">
            
&lt;web-app&gt;
   &lt;listener&gt;
      &lt;listener-class&gt;
         org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap
      &lt;/listener-class&gt;
   &lt;/listener&gt;

  &lt;!-- ** INSERT YOUR LISTENERS HERE!!!! --&gt;

   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;
         org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
      &lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/resteasy/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

        </pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="filter"/>3.5. RESTEasy as a servlet Filter</h2></div></div></div><p>
            The downside of running Resteasy as a Servlet is that you cannot have static resources like .html and .jpeg
            files in the
            same path as your JAX-RS services. Resteasy allows you to run as a Filter instead. If a JAX-RS resource is
            not
            found under the URL requested, Resteasy will delegate back to the base servlet container to resolve URLs.
        </p><pre class="programlisting">
            
&lt;web-app&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;Resteasy&lt;/filter-name&gt;
        &lt;filter-class&gt;
            org.jboss.resteasy.plugins.server.servlet.FilterDispatcher
        &lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;javax.ws.rs.Application&lt;/param-name&gt;
            &lt;param-value&gt;com.restfully.shop.services.ShoppingApplication&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;Resteasy&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

&lt;/web-app&gt;
        </pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e219"/>3.6. Install/Config in JBoss 6-M4 and Higher</h2></div></div></div><p>
            RESTEasy is preconfigured and completely integrated with JBoss 6-M4 and higher. You can use it with EJB
            and CDI and you can rely completely on JBoss for scanning for your JAX-RS services and deploying them. All
            you have to provide is your JAX-RS service classes packaged within a WAR either as POJOs, CDI beans,
            or EJBs and provide an empty web.xml file as follows:
        </p><p>
            </p><pre class="programlisting">
                
&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
&lt;/web-app&gt;

            </pre><p>
        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="RESTEasyLogging"/>3.7. RESTEasyLogging</h2></div></div></div><p>

            RESTEasy supports logging via java.util.logging, Log4j, or Slf4j.  How it picks which framework to delegate to is
	    expressed in the following algorithm:
        </p><div class="itemizedlist"><ul><li><p>If log4j is in the application's classpath, log4j will be used</p></li><li><p>If slf4j is in the application's classpath, slf4j will be used</p></li><li><p>java.util.logging is the default if neither log4j or slf4j is in the classpath</p></li><li><p>If the servlet context param resteasy.logger.type is set to JUL, LOG4J, or SLF4J will override this default behavior</p></li></ul></div><p>
            The logging categories are still a work in progress, but the initial set should make it easier to
            trouleshoot issues. Currently, the framework has defined the following log categories:
        </p><p>

            </p><div class="table"><a id="d0e251"/><p class="title"><b>Table 3.2. </b></p><div class="table-contents"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                                Category
                            </th><th>
                                Function
                            </th></tr></thead><tbody><tr><td>
                                org.jboss.resteasy.core
                            </td><td>
                                Logs all activity by the core RESTEasy implementation
                            </td></tr><tr><td>
                                org.jboss.resteasy.plugins.providers
                            </td><td>
                                Logs all activity by RESTEasy entity providers
                            </td></tr><tr><td>
                                org.jboss.resteasy.plugins.server
                            </td><td>
                                Logs all activity by the RESTEasy server implementation.
                            </td></tr><tr><td>
                                org.jboss.resteasy.specimpl
                            </td><td>
                                Logs all activity by JAX-RS implementing classes
                            </td></tr><tr><td>
                                org.jboss.resteasy.mock
                            </td><td>
                                Logs all activity by the RESTEasy mock framework
                            </td></tr></tbody></table></div></div><p><br class="table-break"/>

        </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Using_Path"/>Chapter 4. Using @Path and @GET, @POST, etc.</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#_Path_and_regular_expression_mappings">4.1. @Path and regular expression mappings</a></span></dt></dl></div><p>

</p><pre class="programlisting">
@Path("/library")
public class Library {

   @GET
   @Path("/books")
   public String getBooks() {...}

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam("isbn") String id) {
      // search my database and get a string representation and return it
   }

   @PUT
   @Path("/book/{isbn}")
   public void addBook(@PathParam("isbn") String id, @QueryParam("name") String name) {...}

   @DELETE
   @Path("/book/{id}")
   public void removeBook(@PathParam("id") String id {...}

   
}
</pre><p>
</p><p>

Let's say you have the Resteasy servlet configured and reachable at a root path of http://myhost.com/services.  The requests would be handled by the Library class:
</p><p>

</p><div class="itemizedlist"><ul><li>
 GET http://myhost.com/services/library/books
</li><li>
 GET http://myhost.com/services/library/book/333
</li><li>
 PUT http://myhost.com/services/library/book/333
</li><li>
 DELETE http://myhost.com/services/library/book/333
</li></ul></div><p>

</p><p>

The @javax.ws.rs.Path annotation must exist on either the class and/or a resource method.  If it exists on both the class and method, the relative path to the resource method is a concatenation of the class and method.
</p><p>

In the @javax.ws.rs package there are annotations for each HTTP method.  @GET, @POST, @PUT, @DELETE, and @HEAD.  You place these on public methods that you want to map to that certain kind of HTTP method.  As long as there is a @Path annotation on the class, you do not have to have a @Path annotation on the method you are mapping.  You can have more than one HTTP method as long as they can be distinguished from other methods.
</p><p>

When you have a @Path annotation on a method without an HTTP method, these are called JAXRSResourceLocators.
</p><p>


</p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_Path_and_regular_expression_mappings"/>4.1. @Path and regular expression mappings</h2></div></div></div><p>

The @Path annotation is not limited to simple path expressions.  You also have the ability to insert regular expressions into @Path's value.  For example:
</p><p>

</p><pre class="programlisting">
@Path("/resources)
public class MyResource {

   @GET
   @Path("{var:.*}/stuff")
   public String get() {...}
}
</pre><p>
</p><p>

The following GETs will route to the getResource() method:
</p><p>

</p><pre class="programlisting">
GET /resources/stuff
GET /resources/foo/stuff
GET /resources/on/and/on/stuff
</pre><p>
</p><p>

The format of the expression is:
</p><p>

</p><pre class="programlisting">
"{" variable-name [ ":" regular-expression ] "}"
</pre><p>
</p><p>

The regular-expression part is optional.  When the expression is not provided, it defaults to a wildcard matching of one particular segment.  In regular-expression terms, the expression defaults to 
</p><pre class="programlisting">
"([]*)"
</pre><p>
</p><p>

For example:
</p><p>

@Path("/resources/{var}/stuff")
</p><p>

will match these:
</p><p>

</p><pre class="programlisting">
GET /resources/foo/stuff
GET /resources/bar/stuff
</pre><p>
</p><p>

but will not match:
</p><p>

</p><pre class="programlisting">
GET /resources/a/bunch/of/stuff
</pre><p>
</p><p>

</p><p>

</p><p>


</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_PathParam"/>Chapter 5. @PathParam</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#Advanced__PathParam_and_Regular_Expressions">5.1. Advanced @PathParam and Regular Expressions</a></span></dt><dt><span class="sect1"><a href="#_PathParam_and_PathSegment">5.2. @PathParam and PathSegment</a></span></dt></dl></div><p>

@PathParam is a parameter annotation which allows you to map variable URI path fragments into your method call.
</p><p>

</p><pre class="programlisting">
@Path("/library")
public class Library {

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam("isbn") String id) {
      // search my database and get a string representation and return it
   }
}
</pre><p>
</p><p>

What this allows you to do is embed variable identification within the URIs of your resources.  In the above example, an isbn URI parameter is used
to pass information about the book we want to access.  The parameter type you inject into can be any primitive type, a String, or any Java object that has
a constructor that takes a String parameter, or a static valueOf method that takes a String as a parameter.  For example, lets say we wanted isbn to be a real object.  We could do:
</p><p>

</p><pre class="programlisting">

   @GET
   @Path("/book/{isbn}")
   public String getBook(@PathParam("isbn") ISBN id) {...}


   public class ISBN {
      public ISBN(String str) {...}
   }

</pre><p>
</p><p>

Or instead of a public String constructors, have a valueOf method:
</p><p>

</p><pre class="programlisting">
  public class ISBN {
     
     public static ISBN valueOf(String isbn) {...}
  }
</pre><p>
</p><p>

</p><p>


</p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Advanced__PathParam_and_Regular_Expressions"/>5.1. Advanced @PathParam and Regular Expressions</h2></div></div></div><p>

There are a few more complicated uses of @PathParams not discussed in the previous section.
</p><p>

</p><p>


</p><p>

You are allowed to specify one or more path params embedded in one URI segment.  Here are some examples:
</p><p>

</p><pre class="programlisting">
1. @Path("/aaa{param}bbb")
2. @Path("/{name}-{zip}")
3. @Path("/foo{name}-{zip}bar")
</pre><p>
</p><p>

So, a URI of "/aaa111bbb" would match #1.  "/bill-02115" would match #2.  "foobill-02115bar" would match #3.
</p><p>


</p><p>

We discussed before how you can use regular expression patterns within @Path values.
</p><p>

</p><pre class="programlisting">

@GET
@Path("/aaa{param:b+}/{many:.*}/stuff")
public String getIt(@PathParam("param") String bs, @PathParam("many") String many) {...}

</pre><p>
</p><p>

For the following requests, lets see what the values of the "param" and "many" @PathParams would be:
</p><p>

</p><div class="table"><a id="d0e428"/><p class="title"><b>Table 5.1. </b></p><div class="table-contents"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>
Request</th><th>
param</th><th>
many</th></tr></thead><tbody><tr><td>
GET /aaabb/some/stuff</td><td>
bb</td><td>
some</td></tr><tr><td>
GET /aaab/a/lot/of/stuff</td><td>
b</td><td>
a/lot/of</td></tr></tbody></table></div></div><p><br class="table-break"/>

</p><p>


</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_PathParam_and_PathSegment"/>5.2. @PathParam and PathSegment</h2></div></div></div><p>

The specification has a very simple abstraction for examining a fragment of the URI path being invoked on  javax.ws.rs.core.PathSegment:
</p><p>

</p><pre class="programlisting">

public interface PathSegment {

    /**
     * Get the path segment.
     * &lt;p&gt;
     * @return the path segment
     */
    String getPath();
    /**
     * Get a map of the matrix parameters associated with the path segment
     * @return the map of matrix parameters
     */
    MultivaluedMap&lt;String, String&gt; getMatrixParameters();
    
}

</pre><p>
</p><p>

You can have Resteasy inject a PathSegment instead of a value with your @PathParam.
</p><p>

</p><pre class="programlisting">
   @GET
   @Path("/book/{id}")
   public String getBook(@PathParam("id") PathSegment id) {...}

</pre><p>
</p><p>

This is very useful if you have a bunch of @PathParams that use matrix parameters.  The idea of matrix parameters is that they are an arbitrary set of name-value pairs embedded in a uri path segment.  The PathSegment object gives you access to theese parameters. See also MatrixParam.
</p><p>

A matrix parameter example is:
</p><p>

GET http://host.com/library/book;name=EJB 3.0;author=Bill Burke
</p><p>

The basic idea of matrix parameters is that it represents resources that are addressable by their attributes as well as their raw id.
</p><p>

</p><p>

</p><p>

</p><p>

</p><p>

</p><p>

</p><p>

</p><p>

</p><p>

</p><p>

</p><p>


</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_QueryParam"/>Chapter 6. @QueryParam</h2></div></div></div><p>

The @QueryParam annotation allows you to map a URI query string parameter or url form encoded parameter to your method invocation.
</p><p>

GET /books?num=5
</p><p>

</p><pre class="programlisting">
   


   @GET
   public String getBooks(@QueryParam("num") int num) {
   ...
   }
</pre><p>
</p><p>

Currently since Resteasy is built on top of a Servlet, it does not distinguish between URI query strings or url form encoded paramters.  Like PathParam, your parameter type can be an String, primitive, or class that has a String constructor or static valueOf() method.
</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_HeaderParam"/>Chapter 7. @HeaderParam</h2></div></div></div><p>

The @HeaderParam annotation allows you to map a request HTTP header to your method invocation.
</p><p>

GET /books?num=5
</p><p>

</p><pre class="programlisting">
   
   @GET
   public String getBooks(@HeaderParam("From") String from) {
   ...
   }
</pre><p>
</p><p>

Like PathParam, your parameter type can be an String, primitive, or class that has a String constructor or static valueOf() method.  For example, MediaType has a valueOf() method and you could do:
</p><p>

</p><pre class="programlisting">

   @PUT
   public void put(@HeaderParam("Content-Type") MediaType contentType, ...)
</pre><p>
</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="LinkHeader"/>Chapter 8. Linking resources</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e550">8.1. Link Headers</a></span></dt><dt><span class="section"><a href="#d0e560">8.2. Atom links in the resource representations</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e573">8.2.1. Configuration</a></span></dt><dt><span class="section"><a href="#d0e605">8.2.2. Your first links injected</a></span></dt><dt><span class="section"><a href="#d0e645">8.2.3. Customising how the Atom links are serialised</a></span></dt><dt><span class="section"><a href="#d0e659">8.2.4. Specifying which JAX-RS methods are tied to which resources</a></span></dt><dt><span class="section"><a href="#d0e799">8.2.5. Specifying path parameter values for URI templates</a></span></dt><dt><span class="section"><a href="#d0e986">8.2.6. Securing entities</a></span></dt><dt><span class="section"><a href="#d0e1042">8.2.7. Extending the UEL context</a></span></dt><dt><span class="section"><a href="#d0e1079">8.2.8. Resource facades</a></span></dt></dl></dd></dl></div><p>
		There are two mechanisms available in RESTEasy to link a resource to another, and to link resources to
		operations: the Link HTTP header, and Atom links inside the resource representations.
	</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e550"/>8.1. Link Headers</h2></div></div></div><p>
		RESTEasy has both client and server side support for the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://tools.ietf.org/html/draft-nottingham-http-link-header-06">Link header specification</a>.
		See the javadocs for org.jboss.resteasy.spi.LinkHeader, org.jboss.resteasy.spi.Link, and org.jboss.resteasy.client.ClientResponse.
		</p><p>
		The main advantage of Link headers over Atom links in the resource is that those links are available
		without parsing the entity body.
		</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e560"/>8.2. Atom links in the resource representations</h2></div></div></div><p>
		RESTEasy allows you to inject <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://tools.ietf.org/html/rfc4287#section-4.2.7">Atom links</a> directly inside the entity objects you are sending to the
		client, via auto-discovery.
		</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>This is only available when using the Jettison or JAXB providers (for JSON and XML).</p></div><p>
		The main advantage over Link headers is that you can have any number of Atom links directly over the
		concerned resources, for any number of resources in the response. For example, you can have Atom links
		for the root response entity, and also for each of its children entities.
		</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e573"/>8.2.1. Configuration</h3></div></div></div><p>
				There is no configuration required to be able to inject Atom links in your resource
				representation, you just have to have this maven artifact in your path:
			</p><table xmlns="" id="d0e578"><caption>Table 8.1. Maven artifact for Atom link injection</caption><thead><tr>
						<th>Group</th>
						<th>Artifact</th>
						<th>Version</th>
					</tr></thead><tbody><tr>
						<td>org.jboss.resteasy</td>
						<td>resteasy-links</td>
						<td>2.2.1.GA</td>
					</tr></tbody></table></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e605"/>8.2.2. Your first links injected</h3></div></div></div><p>
			You need three things in order to tell RESTEasy to inject Atom links in your entities:
			</p><div class="itemizedlist"><ul><li><p>
					Annotate the JAX-RS method with <code class="classname">@AddLinks</code> to indicate that you want
					Atom links injected in your response entity.
					</p></li><li><p>
					Add <code class="classname">RESTServiceDiscovery</code> fields to the resource classes where you
					want Atom links injected.
					</p></li><li><p>
					Annotate the JAX-RS methods you want Atom links for with <code class="classname">@LinkResource</code>,
					so that RESTEasy knows which links to create for which resources.
					</p></li></ul></div><p>
			The following example illustrates how you would declare everything in order to get the Atom links
			injected in your book store:
			</p><pre class="programlisting">@Path("/")
@Consumes({"application/xml", "application/json"})
@Produces({"application/xml", "application/json"})
public interface BookStore {

	@AddLinks
	@LinkResource(value = Book.class)
	@GET
	@Path("books")
	public Collection&lt;Book&gt; getBooks();

	@LinkResource
	@POST
	@Path("books")
	public void addBook(Book book);

	@AddLinks
	@LinkResource
	@GET
	@Path("book/{id}")
	public Book getBook(@PathParam("id") String id);

	@LinkResource
	@PUT
	@Path("book/{id}")
	public void updateBook(@PathParam("id") String id, Book book);

	@LinkResource(value = Book.class)
	@DELETE
	@Path("book/{id}")
	public void deleteBook(@PathParam("id") String id);
}</pre><p>
			And this is the definition of the Book resource:
			</p><pre class="programlisting">@Mapped(namespaceMap = @XmlNsMap(jsonName = "atom", namespace = "http://www.w3.org/2005/Atom"))
@XmlRootElement
@XmlAccessorType(XmlAccessType.NONE)
public class Book {
	@XmlAttribute
	private String author;

	@XmlID
	@XmlAttribute
	private String title;

	@XmlElementRef
	private RESTServiceDiscovery rest;
}</pre><p>
			If you do a GET /order/foo you will then get this XML representation:
			</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;book xmlns:atom="http://www.w3.org/2005/Atom" title="foo" author="bar"&gt;
 &lt;atom:link href="http://localhost:8081/books" rel="list"/&gt;
 &lt;atom:link href="http://localhost:8081/books" rel="add"/&gt;
 &lt;atom:link href="http://localhost:8081/book/foo" rel="self"/&gt;
 &lt;atom:link href="http://localhost:8081/book/foo" rel="update"/&gt;
 &lt;atom:link href="http://localhost:8081/book/foo" rel="remove"/&gt;
&lt;/book&gt;</pre><p>
			And in JSON format:
			</p><pre class="programlisting">{
 "book":
 {
  "@title":"foo",
  "@author":"bar",
  "atom.link":
   [
    {"@href":"http://localhost:8081/books","@rel":"list"},
    {"@href":"http://localhost:8081/books","@rel":"add"},
    {"@href":"http://localhost:8081/book/foo","@rel":"self"},
    {"@href":"http://localhost:8081/book/foo","@rel":"update"},
    {"@href":"http://localhost:8081/book/foo","@rel":"remove"}
   ]
 }
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e645"/>8.2.3. Customising how the Atom links are serialised</h3></div></div></div><p>
			Because the <code class="classname">RESTServiceDiscovery</code> is in fact a JAXB type which inherits from
			<code class="classname">List</code> you are free to annotate it as you want to customise the JAXB serialisation,
			or just rely on the default with <code class="classname">@XmlElementRef</code>.
			</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e659"/>8.2.4. Specifying which JAX-RS methods are tied to which resources</h3></div></div></div><p>
			This is all done by annotating the methods with the <code class="classname">@LinkResource</code> annotation.
			It supports the following optional parameters:
			</p><table xmlns="" id="d0e667"><caption>Table 8.2. <p xmlns="http://www.w3.org/1999/xhtml"><code class="classname">@LinkResource</code> parameters</p></caption><thead><tr>
						<th>Parameter</th>
						<th>Type</th>
						<th>Function</th>
						<th>Default</th>
					</tr></thead><tbody><tr>
						<td>value</td>
						<td><code xmlns="http://www.w3.org/1999/xhtml" class="classname">Class</code></td>
						<td>Declares an Atom link for the given type of resources.</td>
						<td>Defaults to the entity body type (non-annotated parameter), or the method's return type.
						This default does not work with <code xmlns="http://www.w3.org/1999/xhtml" class="classname">Response</code> or <code xmlns="http://www.w3.org/1999/xhtml" class="classname">Collection</code>
						types, they need to be explicitly specified.</td>
					</tr><tr>
						<td>rel</td>
						<td><code xmlns="http://www.w3.org/1999/xhtml" class="classname">String</code></td>
						<td>The Atom link relation</td>
						<td>
							<div xmlns="http://www.w3.org/1999/xhtml" class="variablelist"><dl><dt><span class="term">list</span></dt><dd><p>For <code class="classname">GET</code> methods returning a <code class="classname">Collection</code></p></dd><dt><span class="term">self</span></dt><dd><p>For <code class="classname">GET</code> methods returning a non-<code class="classname">Collection</code></p></dd><dt><span class="term">remove</span></dt><dd><p>For <code class="classname">DELETE</code> methods</p></dd><dt><span class="term">update</span></dt><dd><p>For <code class="classname">PUT</code> methods</p></dd><dt><span class="term">add</span></dt><dd><p>For <code class="classname">POST</code> methods</p></dd></dl></div>
						</td>
					</tr></tbody></table><p>
			You can add several <code class="classname">@LinkResource</code> annotations on a single method by enclosing
			them in	a <code class="classname">@LinkResources</code> annotation. This way you can add links to the same
			method on several resource types. For example the <code class="constant">/order/foo/comments</code> operation
			can belongs on the <code class="classname">Order</code> resource with the <code class="constant">comments</code>
			relation, and on the <code class="classname">Comment</code> resource with the <code class="constant">list</code>
			relation. 
			</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e799"/>8.2.5. Specifying path parameter values for URI templates</h3></div></div></div><p>
			When RESTEasy adds links to your resources it needs to insert the right values in the URI remplate.
			This is done either automatically by guessing the list of values from the entity, or by specifying
			the values in the <code class="classname">@LinkResource</code> <code class="varname">pathParameters</code> parameter.
			</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e810"/>8.2.5.1. Loading URI template values from the entity</h4></div></div></div><p>
					URI template values are extracted from the entity from fields or Java Bean properties
					annotated with <code class="classname">@ResourceID</code>, JAXB's <code class="classname">@XmlID</code> or 
					JPA's <code class="classname">@Id</code>. If there are more than one URI template
					value to find in a given entity, you can annotate your entity with <code class="classname">@ResourceIDs</code>
					to list the names of fields or properties that make up this entity's Id. If there are other
					URI template values required from a parent entity, we try to find that parent in a field or
					Java Bean property
					annotated with <code class="classname">@ParentResource</code>. The list of URI template
					values extracted up every <code class="classname">@ParentResource</code> is then reversed and used
					as the list of values for the URI template.
				</p><p>For example, let's consider the previous Book example, and a list of comments:</p><pre class="programlisting">@XmlRootElement
@XmlAccessorType(XmlAccessType.NONE)
public class Comment {
	@ParentResource
	private Book book;

	@XmlElement
	private String author;

	@XmlID
	@XmlAttribute
	private String id;

	@XmlElementRef
	private RESTServiceDiscovery rest;
}</pre><p>
				Given the previous book store service augmented with comments:
				</p><pre class="programlisting">@Path("/")
@Consumes({"application/xml", "application/json"})
@Produces({"application/xml", "application/json"})
public interface BookStore {

	@AddLinks
	@LinkResources({
		@LinkResource(value = Book.class, rel = "comments"),
		@LinkResource(value = Comment.class)
	})
	@GET
	@Path("book/{id}/comments")
	public Collection&lt;Comment&gt; getComments(@PathParam("id") String bookId);

	@AddLinks
	@LinkResource
	@GET
	@Path("book/{id}/comment/{cid}")
	public Comment getComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

	@LinkResource
	@POST
	@Path("book/{id}/comments")
	public void addComment(@PathParam("id") String bookId, Comment comment);

	@LinkResource
	@PUT
	@Path("book/{id}/comment/{cid}")
	public void updateComment(@PathParam("id") String bookId, @PathParam("cid") String commentId, Comment comment);

	@LinkResource(Comment.class)
	@DELETE
	@Path("book/{id}/comment/{cid}")
	public void deleteComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

}</pre><p>
				Whenever we need to make links for a <code class="classname">Book</code> entity, we look up the ID
				in the <code class="classname">Book</code>'s <code class="classname">@XmlID</code> property. Whenever we make links
				for <code class="classname">Comment</code> entities, we have a list of values taken from the <code class="classname">Comment</code>'s
				<code class="classname">@XmlID</code> and its <code class="classname">@ParentResource</code>: the <code class="classname">Book</code> and
				its <code class="classname">@XmlID</code>.
				</p><p>
				For a <code class="classname">Comment</code> with <code class="varname">id</code> <code class="constant">"1"</code> on a <code class="classname">Book</code>
				with <code class="varname">title</code> <code class="constant">"foo"</code> we will therefore get a list of URI
				template values of <code class="constant">{"foo", "1"}</code>, to be replaced in the URI template, thus
				obtaining either <code class="constant">"/book/foo/comments"</code> or <code class="constant">"/book/foo/comment/1"</code>.
				</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e899"/>8.2.5.2. Specifying path parameters manually</h4></div></div></div><p>
				If you do not want to annotate your entities with resource ID annotations (<code class="classname">@ResourceID</code>,
				<code class="classname">@ResourceIDs</code>, <code class="classname">@XmlID</code> or <code class="classname">@Id</code>) and 
				<code class="classname">@ParentResource</code>, you can also specify the URI template values inside the
				<code class="classname">@LinkResource</code> annotation, using Unified Expression Language expressions:
				</p><table xmlns="" id="d0e922"><caption>Table 8.3. <p xmlns="http://www.w3.org/1999/xhtml"><code class="classname">@LinkResource</code> URI template parameter</p></caption><thead><tr>
							<th>Parameter</th>
							<th>Type</th>
							<th>Function</th>
							<th>Default</th>
						</tr></thead><tbody><tr>
							<td>pathParameters</td>
							<td><code xmlns="http://www.w3.org/1999/xhtml" class="classname">String[]</code></td>
							<td>Declares a list of UEL expressions to obtain the URI template values.</td>
							<td>Defaults to using <code xmlns="http://www.w3.org/1999/xhtml" class="classname">@ResourceID</code>, <code xmlns="http://www.w3.org/1999/xhtml" class="classname">@ResourceIDs</code>,
							<code xmlns="http://www.w3.org/1999/xhtml" class="classname">@XmlID</code> or <code xmlns="http://www.w3.org/1999/xhtml" class="classname">@Id</code> and <code xmlns="http://www.w3.org/1999/xhtml" class="classname">@ParentResource</code>
							annotations to extract the values from the model.</td>
						</tr></tbody></table><p>
				The UEL expressions are evaluated in the context of the entity, which means that any unqualified
				variable will be taken as a property for the entity itself, with the special variable 
				<code class="varname">this</code> bound to the entity we're generating links for.
				</p><p>
				The previous example of <code class="classname">Comment</code> service could be declared as such:
				</p><pre class="programlisting">@Path("/")
@Consumes({"application/xml", "application/json"})
@Produces({"application/xml", "application/json"})
public interface BookStore {

	@AddLinks
	@LinkResources({
		@LinkResource(value = Book.class, rel = "comments", pathParameters = "${title}"),
		@LinkResource(value = Comment.class, pathParameters = {"${book.title}", "${id}"})
	})
	@GET
	@Path("book/{id}/comments")
	public Collection&lt;Comment&gt; getComments(@PathParam("id") String bookId);

	@AddLinks
	@LinkResource(pathParameters = {"${book.title}", "${id}"})
	@GET
	@Path("book/{id}/comment/{cid}")
	public Comment getComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

	@LinkResource(pathParameters = {"${book.title}", "${id}"})
	@POST
	@Path("book/{id}/comments")
	public void addComment(@PathParam("id") String bookId, Comment comment);

	@LinkResource(pathParameters = {"${book.title}", "${id}"})
	@PUT
	@Path("book/{id}/comment/{cid}")
	public void updateComment(@PathParam("id") String bookId, @PathParam("cid") String commentId, Comment comment);

	@LinkResource(Comment.class, pathParameters = {"${book.title}", "${id}"})
	@DELETE
	@Path("book/{id}/comment/{cid}")
	public void deleteComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e986"/>8.2.6. Securing entities</h3></div></div></div><p>
			You can restrict which links are injected in the resource based on security restrictions for the client,
			so that if the current client doesn't have permission to delete a resource he will not be presented
			with the <code class="constant">"delete"</code> link relation.
			</p><p>
			Security restrictions can either be specified on the <code class="classname">@LinkResource</code> annotation,
			or using RESTEasy and EJB's security annotation <code class="classname">@RolesAllowed</code> on the JAX-RS
			method.
			</p><table xmlns="" id="d0e1002"><caption>Table 8.4. <p xmlns="http://www.w3.org/1999/xhtml"><code class="classname">@LinkResource</code> security restrictions</p></caption><thead><tr>
						<th>Parameter</th>
						<th>Type</th>
						<th>Function</th>
						<th>Default</th>
					</tr></thead><tbody><tr>
						<td>constraint</td>
						<td><code xmlns="http://www.w3.org/1999/xhtml" class="classname">String</code></td>
						<td>A UEL expression which must evaluate to true to inject this method's link in the
						response entity.</td>
						<td>Defaults to using <code xmlns="http://www.w3.org/1999/xhtml" class="classname">@RolesAllowed</code> from the JAX-RS method.</td>
					</tr></tbody></table></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1042"/>8.2.7. Extending the UEL context</h3></div></div></div><p>
			We've seen that both the URI template values and the security constraints of <code class="classname">@LinkResource</code>
			use UEL to evaluate expressions, and we provide a basic UEL context with access only to the entity
			we're injecting links in, and nothing more.
			</p><p>
			If you want to add more variables or functions in this
			context, you can by adding a <code class="classname">@LinkELProvider</code> annotation on the JAX-RS method,
			its class, or its package. This annotation's value should point to a class that implements the
			<code class="classname">ELProvider</code> interface, which wraps the default <code class="classname">ELContext</code>
			in order to add any missing functions.
			</p><p>
			For example, if you want to support the Seam annotation <code class="varname">s:hasPermission(target, permission)</code>
			in your security constraints, you can add a <code class="classname">package-info.java</code> file like this:
			</p><pre class="programlisting">@LinkELProvider(SeamELProvider.class)
package org.jboss.resteasy.links.test;

import org.jboss.resteasy.links.*;</pre><p>
			With the following provider implementation:
			</p><pre class="programlisting">package org.jboss.resteasy.links.test;

import javax.el.ELContext;
import javax.el.ELResolver;
import javax.el.FunctionMapper;
import javax.el.VariableMapper;

import org.jboss.seam.el.SeamFunctionMapper;

import org.jboss.resteasy.links.ELProvider;

public class SeamELProvider implements ELProvider {

	public ELContext getContext(final ELContext ctx) {
		return new ELContext() {

			private SeamFunctionMapper functionMapper;

			@Override
			public ELResolver getELResolver() {
				return ctx.getELResolver();
			}

			@Override
			public FunctionMapper getFunctionMapper() {
				if (functionMapper == null)
					functionMapper = new SeamFunctionMapper(ctx
							.getFunctionMapper());
				return functionMapper;
			}

			@Override
			public VariableMapper getVariableMapper() {
				return ctx.getVariableMapper();
			}
		};
	}

}</pre><p>
			And then use it as such:
			</p><pre class="programlisting">@Path("/")
@Consumes({"application/xml", "application/json"})
@Produces({"application/xml", "application/json"})
public interface BookStore {

	@AddLinks
	@LinkResources({
		@LinkResource(value = Book.class, rel = "comments", constraint = "${s:hasPermission(this, 'add-comment')}"),
		@LinkResource(value = Comment.class, constraint = "${s:hasPermission(this, 'insert')}")
	})
	@GET
	@Path("book/{id}/comments")
	public Collection&lt;Comment&gt; getComments(@PathParam("id") String bookId);

	@AddLinks
	@LinkResource(constraint = "${s:hasPermission(this, 'read')}")
	@GET
	@Path("book/{id}/comment/{cid}")
	public Comment getComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

	@LinkResource(constraint = "${s:hasPermission(this, 'insert')}")
	@POST
	@Path("book/{id}/comments")
	public void addComment(@PathParam("id") String bookId, Comment comment);

	@LinkResource(constraint = "${s:hasPermission(this, 'update')}")
	@PUT
	@Path("book/{id}/comment/{cid}")
	public void updateComment(@PathParam("id") String bookId, @PathParam("cid") String commentId, Comment comment);

	@LinkResource(Comment.class, constraint = "${s:hasPermission(this, 'delete')}")
	@DELETE
	@Path("book/{id}/comment/{cid}")
	public void deleteComment(@PathParam("id") String bookId, @PathParam("cid") String commentId);

}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1079"/>8.2.8. Resource facades</h3></div></div></div><p>
			Sometimes it is useful to add resources which are just containers or layers on other resources. For
			example if you want to represent a collection of <code class="classname">Comment</code> with a start index
			and a certain number of entries, in order to implement paging. Such a collection is not really an 
			entity in your model, but it should obtain the <code class="constant">"add"</code> and <code class="constant">"list"</code>
			link relations for the <code class="constant">Comment</code> entity.
			</p><p>
			This is possible using resource facades. A resource facade is a resource which implements the
			<code class="classname">ResourceFacade&lt;T&gt;</code> interface for the type <code class="varname">T</code>, and as
			such, should receive all links for that type.
			</p><p>
			Since in most cases the instance of the <code class="varname">T</code> type is not directly available in the
			resource facade, we need another way to extract its URI template values, and this is done by calling
			the resource facade's <code class="methodname">pathParameters()</code> method to obtain a map of URI template
			values by name. This map will be used to fill in the URI template values for any link generated for
			<code class="varname">T</code>, if there are enough values in the map.
			</p><p>
			Here is an example of such a resource facade for a collection of <code class="classname">Comment</code>s:
			</p><pre class="programlisting">@XmlRootElement
@XmlAccessorType(XmlAccessType.NONE)
public class ScrollableCollection implements ResourceFacade&lt;Comment&gt; {

	private String bookId;
	@XmlAttribute
	private int start;
	@XmlAttribute
	private int totalRecords;
	@XmlElement
	private List&lt;Comment&gt; comments = new ArrayList&lt;Comment&gt;();
	@XmlElementRef
	private RESTServiceDiscovery rest;

	public Class&lt;Comment&gt; facadeFor() {
		return Comment.class;
	}

	public Map&lt;String, ? extends Object&gt; pathParameters() {
		HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
		map.put("id", bookId);
		return map;
	}
}</pre><p>
			This will produce such an XML collection:
			</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;collection xmlns:atom="http://www.w3.org/2005/Atom" totalRecords="2" start="0"&gt;
 &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="add"/&gt;
 &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="list"/&gt;
 &lt;comment xmlid="0"&gt;
  &lt;text&gt;great book&lt;/text&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/0" rel="self"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/0" rel="update"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/0" rel="remove"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="add"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="list"/&gt;
 &lt;/comment&gt;
 &lt;comment xmlid="1"&gt;
  &lt;text&gt;terrible book&lt;/text&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/1" rel="self"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/1" rel="update"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comment/1" rel="remove"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="add"/&gt;
  &lt;atom.link href="http://localhost:8081/book/foo/comments" rel="list"/&gt;
 &lt;/comment&gt;
&lt;/collection&gt;
</pre></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_MatrixParam"/>Chapter 9. @MatrixParam</h2></div></div></div><p>

The idea of matrix parameters is that they are an arbitrary set of name-value pairs embedded in a uri path segment.  
A matrix parameter example is:
</p><p>

GET http://host.com/library/book;name=EJB 3.0;author=Bill Burke
</p><p>

The basic idea of matrix parameters is that it represents resources that are addressable by their attributes as well as their raw id.  The @MatrixParam annotation allows you to inject URI matrix paramters into your method invocation
</p><p>

</p><pre class="programlisting">

   @GET
   public String getBook(@MatrixParam("name") String name, @MatrixParam("author") String author) {...}
</pre><p>
</p><p>

There is one big problem with @MatrixParam that the current version of the specification does not resolve.  What if the same MatrixParam exists twice in different path segments?  In this case, right now, its probably better to use PathParam combined with PathSegment.
</p><p>

</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_CookieParam"/>Chapter 10. @CookieParam</h2></div></div></div><p>

The @CookieParam annotation allows you to inject the value of a cookie or an object representation of an HTTP request cookie into your method invocation
</p><p>

GET /books?num=5
</p><p>

</p><pre class="programlisting">
   


   @GET
   public String getBooks(@CookieParam("sessionid") int id) {
   ...
   }

   @GET
   publi cString getBooks(@CookieParam("sessionid") javax.ws.rs.core.Cookie id) {...}
</pre><p>
</p><p>

Like PathParam, your parameter type can be an String, primitive, or class that has a String constructor or static valueOf() method.  You can also get an object representation of the cookie via the javax.ws.rs.core.Cookie class.
</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_FormParam"/>Chapter 11. @FormParam</h2></div></div></div><p>

When the input request body is of the type "application/x-www-form-urlencoded", a.k.a. an HTML Form, you can inject individual form parameters from the request body into method parameter values.
</p><p>

</p><pre class="programlisting">
&lt;form method="POST" action="/resources/service"&gt;
First name: 
&lt;input type="text" name="firstname"&gt;
&lt;br&gt;
Last name: 
&lt;input type="text" name="lastname"&gt;
&lt;/form&gt;
</pre><p>
</p><p>

If you post through that form, this is what the service might look like:
</p><p>

</p><pre class="programlisting">
@Path("/")
public class NameRegistry {

   @Path("/resources/service")
   @POST
   public void addName(@FormParam("firstname") String first, @FormParam("lastname") String last) {...}

</pre><p>
</p><p>

You cannot combine @FormParam with the default "application/x-www-form-urlencoded" that unmarshalls to a MultivaluedMap&lt;String, String&gt;.  i.e. This is illegal:
</p><p>

</p><pre class="programlisting">
@Path("/")
public class NameRegistry {

   @Path("/resources/service")
   @POST
   @Consumes("application/x-www-form-urlencoded")
   public void addName(@FormParam("firstname") String first, MultivaluedMap&lt;String, String&gt; form) {...}

</pre><p>
</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_Form"/>Chapter 12. @Form</h2></div></div></div><p>

This is a RESTEasy specific annotation that allows you to re-use any @*Param annotation within an injected class.  RESTEasy will instantiate the class and inject values into any annotated @*Param or @Context property.  This is useful if you have a lot of parameters on your method and you want to condense them into a value object.
</p><p>

</p><p>

</p><pre class="programlisting">
public class MyForm {

   @FormParam("stuff")
   private int stuff;


   @HeaderParam("myHeader")
   private String header;


   @PathParam("foo")
   public void setFoo(String foo) {...}
}



@POST
@Path("/myservice")
public void post(@Form MyForm form) {...}
</pre><p>
</p><p>

When somebody posts to /myservice, RESTEasy will instantiate an instance of MyForm and inject the form parameter "stuff" into the "stuff" field, the header "myheader" into the header field, and call the setFoo method with the path param variable of "foo".
</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_DefaultValue"/>Chapter 13. @DefaultValue</h2></div></div></div><p>

@DefaultValue is a parameter annotation that can be combined with any of the other @*Param annotations to define a default value when the HTTP request item does not exist.
</p><p>

</p><pre class="programlisting">
   @GET
   public String getBooks(@QueryParam("num") @DefaultValue("10") int num) {...}
</pre><p>
</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_Encoded_and_encoding"/>Chapter 14. @Encoded and encoding</h2></div></div></div><p>

JAX-RS allows you to get encoded or decoded @*Params and specify path definitions and parameter names using encoded or decoded strings.
</p><p>


</p><p>

The @javax.ws.rs.Encoded annotation can be used on a class, method, or param.  By default, inject @PathParam and @QueryParams are decoded.  By additionally adding the @Encoded annotation, the value of these params will be provided in encoded form.
</p><p>

</p><pre class="programlisting">
@Path("/")
public class MyResource {

  @Path("/{param}")
  @GET
  public String get(@PathParam("param") @Encoded String param) {...}
</pre><p>
</p><p>

In the above example, the value of the @PathParam injected into the param of the get() method will be URL encoded.  Adding the @Encoded annotation as a paramater annotation triggers this affect.
</p><p>

You may also use the @Encoded annotation on the entire method and any combination of @QueryParam or @PathParam's values will be encoded.
</p><p>

</p><pre class="programlisting">
@Path("/")
public class MyResource {
  
   @Path("/{param}")
   @GET
   @Encoded
   public String get(@QueryParam("foo") String foo, @PathParam("param") String param) {}
}


</pre><p>
</p><p>

In the above example, the values of the "foo" query param and "param" path param will be injected as encoded values.
</p><p>

You can also set the default to be encoded for the entire class.
</p><pre class="programlisting">
@Path("/")
@Encoded
public class ClassEncoded {
  
   @GET
   public String get(@QueryParam("foo") String foo) {}
}
</pre><p>
</p><p>


</p><p>

The @Path annotation has an attribute called encode.  Controls whether the literal part of the supplied value (those characters that are not part of a template variable) are URL encoded. If true, any characters in the URI template that are not valid URI character will be automatically encoded. If false then all characters must be valid URI characters.  By default this is set to true.  If you want to encoded the characters yourself, you may.
</p><p>

</p><pre class="programlisting">
@Path(value="hello%20world", encode=false)
</pre><p>
</p><p>


</p><p>

Much like @Path.encode(), this controls whether the specified query param name should be encoded by the container before it tries to find the query param in the request.
</p><p>

</p><pre class="programlisting">
@QueryParam(value="hello%20world", encode=false)
</pre><p>
</p><p>

</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="_Context"/>Chapter 15. @Context</h2></div></div></div><p>

The @Context annotation allows you to inject instances of javax.ws.rs.core.HttpHeaders, javax.ws.rs.core.UriInfo, javax.ws.rs.core.Request, javax.servlet.HttpServletRequest, javax.servlet.HttpServletResponse, javax.servlet.ServletConfig, javax.servlet.ServletContext, and javax.ws.rs.core.SecurityContext objects.
</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JAX-RS_Resource_Locators_and_Sub_Resources"/>Chapter 16. JAX-RS Resource Locators and Sub Resources</h2></div></div></div><p>

Resource classes are able to partially process a request and provide another "sub" resource object that can process the remainder of the request.  For example:
</p><p>

</p><pre class="programlisting">
@Path("/")
public class ShoppingStore {

   @Path("/customers/{id}")
   public Customer getCustomer(@PathParam("id") int id) {
      Customer cust = ...; // Find a customer object
      return cust;
   }
}


public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}

}

</pre><p>
</p><p>

</p><p>

Resource methods that have a @Path annotation, but no HTTP method are considered sub-resource locators.  Their job is to provide an object that can process the request.  In the above example ShoppingStore is a root resource because its class is annotated with @Path.  The getCustomer() method is a sub-resource locator method.
</p><p>

If the client invoked:
</p><p>

</p><pre class="programlisting">GET /customer/123</pre><p>
</p><p>

The ShoppingStore.getCustomer() method would be invoked first.  This method provides a Customer object that can service the request.  The http request will be dispatched to the Customer.get() method.  Another example is:
</p><p>

</p><pre class="programlisting">GET /customer/123/address</pre><p>
</p><p>

In this request, again, first the ShoppingStore.getCustomer() method is invoked.  A customer object is returned, and the rest of the request is dispatched to the Customer.getAddress() method.
</p><p>


</p><p>

Another interesting feature of Sub-resource locators is that the locator method result is dynamically processed at runtime to figure out how to dispatch the request.  So, the ShoppingStore.getCustomer() method does not have to declare any specific type.
</p><p>

</p><pre class="programlisting">
@Path("/")
public class ShoppingStore {

   @Path("/customers/{id}")
   public java.lang.Object getCustomer(@PathParam("id") int id) {
      Customer cust = ...; // Find a customer object
      return cust;
   }
}


public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}

}

</pre><p>
</p><p>

In the above example, getCustomer() returns a java.lang.Object.  Per request, at runtime, the JAX-RS server will figure out how to dispatch the request based on the object returned by getCustomer().  What are the uses of this?  Well, maybe you have a class hierarchy for your customers.  Customer is the abstract base, CorporateCustomer and IndividualCustomer are subclasses.  Your getCustomer() method might be doing a Hibernate polymorphic query and doesn't know, or care, what concrete class is it querying for, or what it returns.
</p><p>

</p><pre class="programlisting">
@Path("/")
public class ShoppingStore {

   @Path("/customers/{id}")
   public java.lang.Object getCustomer(@PathParam("id") int id) {
      Customer cust = entityManager.find(Customer.class, id);
      return cust;
   }
}


public class Customer {
   
    @GET
    public String get() {...}

    @Path("/address")
    public String getAddress() {...}

}

public class CorporateCustomer extendsCustomer {
   
    @Path("/businessAddress")
    public String getAddress() {...}

}

</pre><p>
</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JAX-RS_Content_Negotiation"/>Chapter 17. JAX-RS Content Negotiation</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#media_mappings">17.1. URL-based negotiation</a></span></dt></dl></div><p>

      The HTTP protocol has built in content negotiation headers that allow the client and server to specify what
      content they are transferring and what content they would prefer to get. The server declares content preferences
      via the @Produces and @Consumes headers.
   </p><p>


      @Consumes is an array of media types that a particular resource or resource method consumes. For example:
   </p><p>

      </p><pre class="programlisting">
         @Consumes("text/*")
         @Path("/library")
         public class Library {

         @POST
         public String stringBook(String book) {...}


         @Consumes("text/xml")
         @POST
         public String jaxbBook(Book book) {...}
      </pre><p>
   </p><p>

      When a client makes a request, JAX-RS first finds all methods that match the path, then, it sorts things based on
      the content-type header sent by the client.
      So, if a client sent:
   </p><p>

      </p><pre class="programlisting">
         POST /library
         content-type: text/plain

         thsi sis anice book
      </pre><p>
   </p><p>

      The stringBook() method would be invoked because it matches to the default "text/*" media type. Now, if
      the client instead sends XML:
   </p><p>

      </p><pre class="programlisting">
         POST /library
         content-type: text/xml

         &lt;book name="EJB 3.0" author="Bill Burke"/&gt;
      </pre><p>
   </p><p>

      The jaxbBook() method would be invoked.
   </p><p>


      The @Produces is used to map a client request and match it up to the client's Accept header. The Accept HTTP
      header is sent by the client and defines the media types the client prefers to receive from the server.
   </p><p>


      </p><pre class="programlisting">
         @Produces("text/*")
         @Path("/library")
         public class Library {

         @GET
         @Produces("application/json")
         public String getJSON() {...}


         @GET
         public String get() {...}
      </pre><p>
   </p><p>

      So, if the client sends:
   </p><p>

      </p><pre class="programlisting">
         GET /library
         Accept: application/json
      </pre><p>
   </p><p>

      The getJSON() method would be invoked
   </p><p>


      @Consumes and @Produces can list multiple media types that they support. The client's Accept header can also send
      multiple types it might like to receive. More specific media types are chosen first. The client Accept header or
      @Produces @Consumes can also specify weighted preferences that are used to match up requests with resource
      methods. This is best explained by RFC 2616 section 14.1 . Resteasy supports this complex way of doing content
      negotiation.
   </p><p>


   </p><p>

      A variant in JAX-RS is a combination of media type, content-language, and content encoding as well as etags, last
      modified headers, and other preconditions. This is a more complex form of content negotiation that is done
      programmatically by the application developer using the javax.ws.rs.Variant, VarianListBuilder, and Request
      objects. Request is injected via @Context. Read the javadoc for more info on these.
   </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="media_mappings"/>17.1. URL-based negotiation</h2></div></div></div><p>
Some clients, like browsers, cannot use the Accept and Accept-Language headers to negotiation the representation's media type
or language.  RESTEasy allows you to map file name suffixes like (.xml, .txt, .en, .fr) to media types and languages.  These file name suffixes
take the place and override any Accept header sent by the client.  You configure this using the resteasy.media.type.mappings and resteasy.language.mappings
context-param variables within your web.xml
</p><pre class="programlisting">

&lt;web-app&gt;
    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.media.type.mappings&lt;/param-name&gt;
        &lt;param-value&gt;html : text/html, json : application/json, xml : application/xml&lt;/param-value&gt;
    &lt;/context-param&gt;

   &lt;context-param&gt;
        &lt;param-name&gt;resteasy.language.mappings&lt;/param-name&gt;
        &lt;param-value&gt; en : en-US, es : es, fr : fr&lt;/param-name&gt;
   &lt;/context-param&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;

</pre><p>
Mappings are a comma delimited list of suffix/mediatype or suffix/language mappings.  Each mapping is delimited by a ':'.  So, if you invoked GET /foo/bar.xml.en, this would be equivalent to invoking the following request:
</p><pre class="programlisting">
GET /foo/bar
Accept: application/xml
Accept-Language: en-US
</pre><p>
The mapped file suffixes are stripped from the target URL path before the request is dispatched to a corresponding JAX-RS resource.
</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Content_Marshalling_Providers"/>Chapter 18. Content Marshalling/Providers</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#Default_Providers_and_default_JAX-RS_Content_Marshalling">18.1. Default Providers and default JAX-RS Content Marshalling</a></span></dt><dt><span class="sect1"><a href="#Content_Marshalling_with__Provider_classes">18.2. Content Marshalling with @Provider classes</a></span></dt><dt><span class="sect1"><a href="#MessageBodyWorkers">18.3. Providers Utility Class</a></span></dt></dl></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Default_Providers_and_default_JAX-RS_Content_Marshalling"/>18.1. Default Providers and default JAX-RS Content Marshalling</h2></div></div></div><p>

         Resteasy can automatically marshal and unmarshal a few different message bodies.
      </p><p>

         </p><div class="table"><a id="d0e1408"/><p class="title"><b>Table 18.1. </b></p><div class="table-contents"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th>
                        Media Types
                     </th><th>
                        Java Type
                     </th></tr></thead><tbody><tr><td>
                        application/*+xml, text/*+xml, application/*+json, application/*+fastinfoset, application/atom+*
                     </td><td>
                        JaxB annotated classes
                     </td></tr><tr><td>
                        application/*+xml, text/*+xml
                     </td><td>
                        org.w3c.dom.Document
                     </td></tr><tr><td>
                        */*
                     </td><td>
                        java.lang.String
                     </td></tr><tr><td>
                        */*
                     </td><td>
                        java.io.InputStream
                     </td></tr><tr><td>
                        text/plain
                     </td><td>
                        primtives, java.lang.String, or any type that has a String constructor, or static
                        valueOf(String) method for input, toString() for output
                     </td></tr><tr><td>
                        */*
                     </td><td>
                        javax.activation.DataSource
                     </td></tr><tr><td>
                        */*
                     </td><td>
                        java.io.File
                     </td></tr><tr><td>
                        */*
                     </td><td>
                        byte[]
                     </td></tr><tr><td>
                        application/x-www-form-urlencoded
                     </td><td>
                        javax.ws.rs.core.MultivaluedMap
                     </td></tr></tbody></table></div></div><p><br class="table-break"/>

      </p><p>

      </p><p>

      </p><p>


      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Content_Marshalling_with__Provider_classes"/>18.2. Content Marshalling with @Provider classes</h2></div></div></div><p>

         The JAX-RS specification allows you to plug in your own request/response body reader and writers. To do this,
         you annotate a class
         with @Provider and specify the @Produces types for a writer and @Consumes types for a reader. You must
         also implement
         a MessageBodyReader/Writer interface respectively. Here is an example.
      </p><p>


         The Resteasy ServletContextLoader will automatically scan your WEB-INF/lib and classes directories for classes
         annotated with @Provider or you can manually configure them in web.xml. See Installation/Configuration
      </p><p>


      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="MessageBodyWorkers"/>18.3. Providers Utility Class</h2></div></div></div><p>

         javax.ws.rs.ext.Providers is a simple injectable interface that allows you to look up MessageBodyReaders,
          Writers, ContextResolvers, and ExceptionMappers. It is very useful, for instance, for implementing
          multipart providers. Content types that embed
         other random content types.
      </p><p>

         </p><pre class="programlisting">

public interface Providers
{

   /**
    * Get a message body reader that matches a set of criteria. The set of
    * readers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each reader's
    * {@link javax.ws.rs.Consumes}, ensuring the supplied value of
    * {@code type} is assignable to the generic type of the reader, and
    * eliminating those that do not match.
    * The list of matching readers is then ordered with those with the best
    * matching values of {@link javax.ws.rs.Consumes} (x/y &gt; x&amp;#47;* &gt; *&amp;#47;*)
    * sorted first. Finally, the
    * {@link MessageBodyReader#isReadable}
    * method is called on each reader in order using the supplied criteria and
    * the first reader that returns {@code true} is selected and returned.
    *
    * @param type        the class of object that is to be written.
    * @param mediaType   the media type of the data that will be read.
    * @param genericType the type of object to be produced. E.g. if the
    *                    message body is to be converted into a method parameter, this will be
    *                    the formal type of the method parameter as returned by
    *                    &lt;code&gt;Class.getGenericParameterTypes&lt;/code&gt;.
    * @param annotations an array of the annotations on the declaration of the
    *                    artifact that will be initialized with the produced instance. E.g. if the
    *                    message body is to be converted into a method parameter, this will be
    *                    the annotations on that parameter returned by
    *                    &lt;code&gt;Class.getParameterAnnotations&lt;/code&gt;.
    * @return a MessageBodyReader that matches the supplied criteria or null
    *         if none is found.
    */
   &lt;T&gt; MessageBodyReader&lt;T&gt; getMessageBodyReader(Class&lt;T&gt; type,
                                                 Type genericType, Annotation annotations[], MediaType mediaType);

   /**
    * Get a message body writer that matches a set of criteria. The set of
    * writers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each writer's
    * {@link javax.ws.rs.Produces}, ensuring the supplied value of
    * {@code type} is assignable to the generic type of the reader, and
    * eliminating those that do not match.
    * The list of matching writers is then ordered with those with the best
    * matching values of {@link javax.ws.rs.Produces} (x/y &gt; x&amp;#47;* &gt; *&amp;#47;*)
    * sorted first. Finally, the
    * {@link MessageBodyWriter#isWriteable}
    * method is called on each writer in order using the supplied criteria and
    * the first writer that returns {@code true} is selected and returned.
    *
    * @param mediaType   the media type of the data that will be written.
    * @param type        the class of object that is to be written.
    * @param genericType the type of object to be written. E.g. if the
    *                    message body is to be produced from a field, this will be
    *                    the declared type of the field as returned by
    *                    &lt;code&gt;Field.getGenericType&lt;/code&gt;.
    * @param annotations an array of the annotations on the declaration of the
    *                    artifact that will be written. E.g. if the
    *                    message body is to be produced from a field, this will be
    *                    the annotations on that field returned by
    *                    &lt;code&gt;Field.getDeclaredAnnotations&lt;/code&gt;.
    * @return a MessageBodyReader that matches the supplied criteria or null
    *         if none is found.
    */
   &lt;T&gt; MessageBodyWriter&lt;T&gt; getMessageBodyWriter(Class&lt;T&gt; type,
                                                 Type genericType, Annotation annotations[], MediaType mediaType);

   /**
    * Get an exception mapping provider for a particular class of exception.
    * Returns the provider whose generic type is the nearest superclass of
    * {@code type}.
    *
    * @param type the class of exception
    * @return an {@link ExceptionMapper} for the supplied type or null if none
    *         is found.
    */
   &lt;T extends Throwable&gt; ExceptionMapper&lt;T&gt; getExceptionMapper(Class&lt;T&gt; type);

   /**
    * Get a context resolver for a particular type of context and media type.
    * The set of resolvers is first filtered by comparing the supplied value of
    * {@code mediaType} with the value of each resolver's
    * {@link javax.ws.rs.Produces}, ensuring the generic type of the context
    * resolver is assignable to the supplied value of {@code contextType}, and
    * eliminating those that do not match. If only one resolver matches the
    * criteria then it is returned. If more than one resolver matches then the
    * list of matching resolvers is ordered with those with the best
    * matching values of {@link javax.ws.rs.Produces} (x/y &gt; x&amp;#47;* &gt; *&amp;#47;*)
    * sorted first. A proxy is returned that delegates calls to
    * {@link ContextResolver#getContext(java.lang.Class)} to each matching context
    * resolver in order and returns the first non-null value it obtains or null
    * if all matching context resolvers return null.
    *
    * @param contextType the class of context desired
    * @param mediaType   the media type of data for which a context is required.
    * @return a matching context resolver instance or null if no matching
    *         context providers are found.
    */
   &lt;T&gt; ContextResolver&lt;T&gt; getContextResolver(Class&lt;T&gt; contextType,
                                             MediaType mediaType);
}

         </pre><p>
      </p><p>


      </p><p>

         A Providers instance is injectable into MessageBodyReader or Writers:
      </p><p>

         </p><pre class="programlisting">
            @Provider
            @Consumes("multipart/fixed")
            public class MultipartProvider implements MessageBodyReader {

            private @Context Providers providers;

            ...

            }
         </pre><p>
      </p><p>


      </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Built_in_JAXB_providers"/>Chapter 19. JAXB providers</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#decorators">19.1. JAXB Decorators</a></span></dt><dt><span class="sect1"><a href="#Pluggable_JAXBContext_s_with_ContextResolvers">19.2. Pluggable JAXBContext's with ContextResolvers</a></span></dt><dt><span class="sect1"><a href="#JAXB_+_XML_provider">19.3. JAXB + XML provider</a></span></dt><dd><dl><dt><span class="sect2"><a href="#XmlHeader">19.3.1. @XmlHeader and @Stylesheet</a></span></dt></dl></dd><dt><span class="sect1"><a href="#JAXB_+_JSON_provider">19.4. JAXB + JSON provider</a></span></dt><dt><span class="sect1"><a href="#JAXB_+_FastinfoSet_provider">19.5. JAXB + FastinfoSet provider</a></span></dt><dt><span class="sect1"><a href="#JAXB_Collections">19.6. Arrays and Collections of JAXB Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#json_list">19.6.1. JSON and JAXB Collections/arrays</a></span></dt></dl></dd><dt><span class="sect1"><a href="#JAXB_Map">19.7. Maps of JAXB Objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#json_map">19.7.1. JSON and JAXB maps</a></span></dt><dt><span class="sect2"><a href="#JAXB_JSON_problems">19.7.2. Possible Problems with Jettison Provider</a></span></dt></dl></dd><dt><span class="sect1"><a href="#JAXB_INTERFACES">19.8. Interfaces, Abstract Classes, and JAXB</a></span></dt></dl></div><p>

      As required by the specification, RESTEasy JAX-RS includes support for (un)marshalling JAXB annotated classes.
      RESTEasy provides multiple JAXB Providers to address some subtle differences between classes generated by XJC
      and classes which are simply annotated with @XmlRootElement, or working with JAXBElement classes directly.
   </p><p>

      For the most part, developers using the JAX-RS API, the selection of which provider is invoked will be
      completely transparent. For developers wishing to access the providers directly (which most folks won't need to
      do), this document describes which provider is best suited for different configurations.
   </p><p>

      A JAXB Provider is selected by RESTEasy when a parameter or return type is an object that is annotated with
      JAXB annotations (such as @XmlRootEntity or @XmlType) or if the type is a JAXBElement. Additionally, the
      resource class or resource method will be annotated with either a @Consumes or @Produces annotation and
      contain one or more of the following values:
   </p><p>

      </p><div class="itemizedlist"><ul><li>
            text/*+xml
         </li><li>
            application/*+xml
         </li><li>
            application/*+fastinfoset
         </li><li>
            application/*+json
         </li></ul></div><p>

   </p><p>

   </p><p>

      RESTEasy will select a different provider based on the return type or parameter type used in the resource. This
      section decribes how the selection process works.
   </p><p>

      @XmlRootEntity
      When a class is annotated with a @XmlRootElement annotation, RESTEasy will select the
      JAXBXmlRootElementProvider. This provider handles basic marhaling and and unmarshalling of custom JAXB
      entities.
   </p><p>

      @XmlType
      Classes which have been generated by XJC will most likely not contain an @XmlRootEntity annotation. In order
      for these classes to marshalled, they must be wrapped within a JAXBElement instance. This is typically
      accomplished by invoking a method on the class which serves as the XmlRegistry and is named ObjectFactory.
   </p><p>

      The JAXBXmlTypeProvider provider is selected when the class is annotated with an XmlType annotation and not an
      XmlRootElement annotation.
   </p><p>

      This provider simplifies this task by attempting to locate the XmlRegistry for the target class. By default, a
      JAXB implementation will create a class called ObjectFactory and is located in the same package as the target
      class. When this class is located, it will contain a "create" method that takes the object instance
      as a parameter. For example, of the target type is called "Contact", then the ObjectFactory class
      will have a method:
   </p><p>

      public JAXBElement createContact(Contact value) {..
   </p><p>

      JAXBElement&lt;?&gt;
      If your resource works with the JAXBElement class directly, the RESTEasy runtime will select the
      JAXBElementProvider. This provider examines the ParameterizedType value of the JAXBElement in order to select
      the appropriate JAXBContext.
   </p><p>

   </p><p>


   </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="decorators"/>19.1. JAXB Decorators</h2></div></div></div><p>Resteasy's JAXB providers have a pluggable way to decorate Marshaller and Unmarshaller instances.
        The way it works is that you can write an annotation that can trigger the decoration of a
        Marshaller or Unmarshaller.  Your decorators can do things like set Marshaller or Unmarshaller properties,
        set up validation, stuff like that.  Here's an example.  Let's say we want to have an annotation
        that will trigger pretty-printing, nice formatting, of an XML document.  If we were doing raw
        JAXB, we would set a property on the Marshaller of Marshaller.JAXB_FORMATTED_OUTPUT.  Let's
        write a Marshaller decorator.</p><p>First we define a annotation:</p><pre class="programlisting">

 import org.jboss.resteasy.annotations.Decorator;

 @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})
 @Retention(RetentionPolicy.RUNTIME)
 @Decorator(processor = PrettyProcessor.class, target = Marshaller.class)
 public @interface Pretty {}
 </pre><p>To get this to work, we must annotate our @Pretty annotation with a meta-annotation called
        @Decorator.  The target() attribute must be the JAXB Marshaller class.  The processor()
        attribute is a class we will write next.</p><pre class="programlisting">
 
 import org.jboss.resteasy.core.interception.DecoratorProcessor;
 import org.jboss.resteasy.annotations.DecorateTypes;

 import javax.xml.bind.Marshaller;
 import javax.xml.bind.PropertyException;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.Produces;
 import java.lang.annotation.Annotation;

 /**
  * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
  * @version $Revision: 1 $
  */
 @DecorateTypes({"text/*+xml", "application/*+xml"})
 public class PrettyProcessor implements DecoratorProcessor&lt;Marshaller, Pretty&gt;
 {
    public Marshaller decorate(Marshaller target, Pretty annotation,
                  Class type, Annotation[] annotations, MediaType mediaType)
    {
       target.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
    }
 }
 
 </pre><p>
        The processor implementation must implement the DecoratorProcessor interface and should also be annotated
        with @DecorateTypes.  This annotation specifies what media types the processor can be used with. Now that
        we've defined our annotation and our Processor, we can use it on our JAX-RS resource methods
        or JAXB types as follows:
    </p><pre class="programlisting">
   @GET
   @Pretty
   @Produces("application/xml")
   public SomeJAXBObject get() {...}
 </pre><p>If you are confused, check the Resteasy source code for the implementation of @XmlHeader</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Pluggable_JAXBContext_s_with_ContextResolvers"/>19.2. Pluggable JAXBContext's with ContextResolvers</h2></div></div></div><p>

         You should not use this feature unless you know what you're doing.
      </p><p>

         Based on the class you are marshalling/unmarshalling, RESTEasy will, by default create and cache JAXBContext
         instances per class type. If you do not want RESTEasy to create JAXBContexts, you can plug-in your own by
         implementing an instance of javax.ws.rs.ext.ContextResolver
      </p><p>

 </p><pre class="programlisting">
 public interface ContextResolver&lt;T&gt;
 {
T getContext(Class&lt;?&gt; type);
 }

 @Provider
 @Produces("application/xml")
 public class MyJAXBContextResolver implements ContextResolver&lt;JAXBContext&gt;
 {
JAXBContext getContext(Class&lt;?&gt; type)
{
   if (type.equals(WhateverClassIsOverridedFor.class)) return JAXBContext.newInstance()...;
}
 }
         </pre><p>
      </p><p>

         You must provide a @Produces annotation to specify the media type the context is meant for. You must also
         make sure to implement ContextResolver&lt;JAXBContext&gt;. This helps the runtime match to the correct
         context resolver. You must also annotate the ContextResolver class with @Provider.
      </p><p>

         There are multiple ways to make this ContextResolver available.
      </p><p>

         </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li>
               Return it as a class or instance from a javax.ws.rs.core.Application implementation
            </li><li>
               List it as a provider with resteasy.providers
            </li><li>
               Let RESTEasy automatically scan for it within your WAR file. See Configuration Guide
            </li><li>
               Manually add it via ResteasyProviderFactory.getInstance().registerProvider(Class) or
               registerProviderInstance(Object)
            </li></ol></div><p>

      </p><p>


      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_+_XML_provider"/>19.3. JAXB + XML provider</h2></div></div></div><p>
           Resteasy is required to provide JAXB provider support for XML.  It has a few extra annotations
           that can help code your app.
       </p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="XmlHeader"/>19.3.1. @XmlHeader and @Stylesheet</h3></div></div></div><p>Sometimes when outputting XML documents you may want to set an XML header. Resteasy provides
           the @org.jboss.resteasy.annotations.providers.jaxb.XmlHeader annotation for this.  For example:</p><pre class="programlisting">
 
@XmlRootElement
public static class Thing
{
   private String name;

   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
}

@Path("/test")
public static class TestService
{

   @GET
   @Path("/header")
   @Produces("application/xml")
   @XmlHeader("&lt;?xml-stylesheet type='text/xsl' href='${baseuri}foo.xsl' ?&gt;")
   public Thing get()
   {
      Thing thing = new Thing();
      thing.setName("bill");
      return thing;
   }
}
 </pre><p>
               The @XmlHeader here forces the XML output to have an xml-stylesheet header.  This header
               could also have been put on the Thing class to get the same result.  See the javadocs for more
               details on how you can use substitution values provided by resteasy.
               </p><p>
               Resteasy also has a convinience annotation for stylesheet headers.  For example:
           </p><pre class="programlisting">
 
@XmlRootElement
public static class Thing
{
   private String name;

   public String getName()
   {
      return name;
   }

   public void setName(String name)
   {
      this.name = name;
   }
}

@Path("/test")
public static class TestService
{

   @GET
   @Path("/stylesheet")
   @Produces("application/xml")
   @Stylesheet(type="text/css", href="${basepath}foo.xsl")
   @Junk
   public Thing getStyle()
   {
      Thing thing = new Thing();
      thing.setName("bill");
      return thing;
   }
}
 </pre></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_+_JSON_provider"/>19.4. JAXB + JSON provider</h2></div></div></div><p>

         RESTEasy allows you to marshall JAXB annotated POJOs to and from JSON. This provider wraps the Jettison JSON
         library to accomplish this.  You can obtain more information about Jettison and how it works from:
      </p><p>
     http://jettison.codehaus.org/
  </p><p>
           To use this integration with Jettision you need to import the resteasy-jettison-provider Maven module.  Older versions
           of RESTEasy used to include this within the resteasy-jaxb-provider but we decided to modularize it more.
       </p><p>
    Jettison has two mapping formats. One is BadgerFish the other is a Jettison
        Mapped Convention format.  The Mapped Convention is the default mapping.
      </p><p>

      </p><p>

         For example, consider this JAXB class:
      </p><p>

 </p><pre class="programlisting">
 @XmlRootElement(name = "book")
 public class Book
 {
private String author;
private String ISBN;
private String title;

public Book()
{
}

public Book(String author, String ISBN, String title)
{
   this.author = author;
   this.ISBN = ISBN;
   this.title = title;
}

@XmlElement
public String getAuthor()
{
   return author;
}

public void setAuthor(String author)
{
   this.author = author;
}

@XmlElement
public String getISBN()
{
   return ISBN;
}

public void setISBN(String ISBN)
{
   this.ISBN = ISBN;
}

@XmlAttribute
public String getTitle()
{
   return title;
}

public void setTitle(String title)
{
   this.title = title;
}
 }
         </pre><p>
      </p><p>


      </p><p>

         This is how the JAXB Book class would be marshalled to JSON using the BadgerFish Convention
      </p><p>

 </p><pre class="programlisting">
 {"book":
    {
       "@title":"EJB 3.0",
       "author":{"$":"Bill Burke"},
       "ISBN":{"$":"596529260"}
    }
 }
 </pre><p>
      </p><p>

         Notice that element values have a map associated with them and to get to the value of the element, you must
         access the "$" variable. Here's an example of accessing the book in Javascript:
      </p><p>

 </p><pre class="programlisting">
 var data = eval("(" + xhr.responseText + ")");
 document.getElementById("zone").innerHTML = data.book.@title;
 document.getElementById("zone").innerHTML += data.book.author.$;
 </pre><p>
      </p><p>


      </p><p>

         To use the BadgerFish Convention you must use the
         @org.jboss.resteasy.annotations.providers.jaxb.json.BadgerFish annotation on the JAXB class you are
         marshalling/unmarshalling, or, on the JAX-RS resource method or parameter:
      </p><p>

 </p><pre class="programlisting">
 @BadgerFish
 @XmlRootElement(name = "book")
 public class Book {...}
 </pre><p>
      </p><p>

         If you are returning a book on the JAX-RS method and you don't want to (or can't) pollute your JAXB classes
         with RESTEasy annotations, add the annotation to the JAX-RS method:
      </p><p>

 </p><pre class="programlisting">
 @BadgerFish
 @GET
 public Book getBook(...) {...}
 </pre><p>
      </p><p>

         If a Book is your input then you put it on the parameter:
      </p><p>

 </p><pre class="programlisting">
 @POST
 public void newBook(@BadgerFish Book book) {...}
 </pre><p>
      </p><p>


      </p><p>

         The default Jettison Mapped Convention would return JSON that looked like this:
      </p><p>

 </p><pre class="programlisting">
 { "book" :
      {
         "@title":"EJB 3.0",
         "author":"Bill Burke",
         "ISBN":596529260
       }
 }
 </pre><p>
      </p><p>

         Notice that the @XmlAttribute "title" is prefixed with the '@' character. Unlike BadgerFish, the
         '$' does not represent the value of element text. This format is a bit simpler than the BadgerFish
         convention which is why it was chose as a default. Here's an example of accessing this in Javascript:
      </p><p>

 </p><pre class="programlisting">
 var data = eval("(" + xhr.responseText + ")");
 document.getElementById("zone").innerHTML = data.book.@title;
 document.getElementById("zone").innerHTML += data.book.author;
 </pre><p>
      </p><p>


      </p><p>

         The Mapped Convention allows you to fine tune the JAXB mapping using the
         @org.jboss.resteasy.annotations.providers.jaxb.json.Mapped annotation. You can provide an XML Namespace to
         JSON namespace mapping. For example, if you defined your JAXB namespace within your package-info.java class like this:
  </p><pre class="programlisting">
 @javax.xml.bind.annotation.XmlSchema(namespace="http://jboss.org/books")
 package org.jboss.resteasy.test.books;
 </pre><p>
      You would have to define a JSON to XML namespace mapping or you would receive an exception of something like this:
  </p><pre class="programlisting">
 java.lang.IllegalStateException: Invalid JSON namespace: http://jboss.org/books
 at org.codehaus.jettison.mapped.MappedNamespaceConvention.getJSONNamespace(MappedNamespaceConvention.java:151)
 at org.codehaus.jettison.mapped.MappedNamespaceConvention.createKey(MappedNamespaceConvention.java:158)
 at org.codehaus.jettison.mapped.MappedXMLStreamWriter.writeStartElement(MappedXMLStreamWriter.java:241)
 </pre><p>
        To fix this problem you need another annotation, @Mapped.  You use the @Mapped annotation on your JAXB classes, on your JAX-RS resource method, or on
        the parameter you are unmarshalling
  </p><pre class="programlisting">
 import org.jboss.resteasy.annotations.providers.jaxb.json.Mapped;
 import org.jboss.resteasy.annotations.providers.jaxb.json.XmlNsMap;

 ...

@GET
@Produces("application/json")
@Mapped(namespaceMap = {
        @XmlNsMap(namespace = "http://jboss.org/books", jsonName = "books")
})
public Book get() {...}

 </pre><p>
      Besides mapping XML to JSON namespaces, you can also force @XmlAttribute's to be marshaled as XMLElements.
      </p><p>

         </p><pre class="programlisting">
            @Mapped(attributeAsElements={"title"})
            @XmlRootElement(name = "book")
            public class Book {...}
         </pre><p>
      </p><p>

         If you are returning a book on the JAX-RS method and you don't want to (or can't) pollute your JAXB classes
         with RESTEasy annotations, add the annotation to the JAX-RS method:
      </p><p>

         </p><pre class="programlisting">
            @Mapped(attributeAsElements={"title"})
            @GET
            public Book getBook(...) {...}
         </pre><p>
      </p><p>

         If a Book is your input then you put it on the parameter:
      </p><p>

 </p><pre class="programlisting">
 @POST
 public void newBook(@Mapped(attributeAsElements={"title"}) Book book) {...}
 </pre><p>
      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>

      </p><p>


      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_+_FastinfoSet_provider"/>19.5. JAXB + FastinfoSet provider</h2></div></div></div><p>

         RESTEasy supports the FastinfoSet mime type with JAXB annotated classes. Fast infoset documents are faster
         to serialize and parse, and smaller in size, than logically equivalent XML documents. Thus, fast infoset
         documents may be used whenever the size and processing time of XML documents is an issue. It is configured
         the same way the XML JAXB provider is so really no other documentation is needed here.
      </p><p>
           To use this integration with Fastinfoset you need to import the resteasy-fastinfoset-provider Maven module.  Older versions
           of RESTEasy used to include this within the resteasy-jaxb-provider but we decided to modularize it more.
       </p><p>


      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_Collections"/>19.6. Arrays and Collections of JAXB Objects</h2></div></div></div><p>
         RESTEasy will automatically
         marshal arrays, java.util.Set's, and java.util.List's of JAXB objects to and from XML, JSON, Fastinfoset (or any other new JAXB mapper Restasy comes up with).
      </p><pre class="programlisting">
 @XmlRootElement(name = "customer")
 @XmlAccessorType(XmlAccessType.FIELD)
 public class Customer
 {
@XmlElement
private String name;

public Customer()
{
}

public Customer(String name)
{
   this.name = name;
}

public String getName()
{
   return name;
}
 }

 @Path("/")
 public class MyResource
 {
   @PUT
   @Path("array")
   @Consumes("application/xml")
   public void putCustomers(Customer[] customers)
   {
      Assert.assertEquals("bill", customers[0].getName());
      Assert.assertEquals("monica", customers[1].getName());
   }

   @GET
   @Path("set")
   @Produces("application/xml")
   public Set&lt;Customer&gt; getCustomerSet()
   {
      HashSet&lt;Customer&gt; set = new HashSet&lt;Customer&gt;();
      set.add(new Customer("bill"));
      set.add(new Customer("monica"));

      return set;
   }


   @PUT
   @Path("list")
   @Consumes("application/xml")
   public void putCustomers(List&lt;Customer&gt; customers)
   {
      Assert.assertEquals("bill", customers.get(0).getName());
      Assert.assertEquals("monica", customers.get(1).getName());
   }
 }
 
 </pre><p>
      The above resource can publish and receive JAXB objects.  It is assumed that are wrapped in a collection element
   </p><pre class="programlisting">
 &lt;collection&gt;
&lt;customer&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/customer&gt;
&lt;customer&gt;&lt;name&gt;monica&lt;/name&gt;&lt;/customer&gt;
 &lt;collection&gt;
 
 </pre><p>You can change the namespace URI, namespace tag, and collection element name by using the @org.jboss.resteasy.annotations.providers.jaxb.Wrapped annotation on a parameter or method</p><pre class="programlisting">
 @Target({ElementType.PARAMETER, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface Wrapped
 {
String element() default "collection";

String namespace() default "http://jboss.org/resteasy";

String prefix() default "resteasy";
 }
 </pre><p>So, if we wanted to output this XML</p><pre class="programlisting">
 &lt;foo:list xmlns:foo="http://foo.org"&gt;
&lt;customer&gt;&lt;name&gt;bill&lt;/name&gt;&lt;/customer&gt;
&lt;customer&gt;&lt;name&gt;monica&lt;/name&gt;&lt;/customer&gt;
 &lt;/foo:list&gt;
 
 </pre><p>We would use the @Wrapped annotation as follows: </p><pre class="programlisting">
   @GET
   @Path("list")
   @Produces("application/xml")
   @Wrapped(element="list", namespace="http://foo.org", prefix="foo")
   public List&lt;Customer&gt; getCustomerSet()
   {
      List&lt;Customer&gt; list = new ArrayList&lt;Customer&gt;();
      list.add(new Customer("bill"));
      list.add(new Customer("monica"));

      return list;
   }
 
 </pre><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="json_list"/>19.6.1. JSON and JAXB Collections/arrays</h3></div></div></div><p>Resteasy supports using collections with JSON.  It encloses lists, sets, or arrays of returned JAXB objects within a simple
    JSON array.  For example:</p><pre class="programlisting">
   @XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Foo
{
   @XmlAttribute
   private String test;

   public Foo()
   {
   }

   public Foo(String test)
   {
      this.test = test;
   }

   public String getTest()
   {
      return test;
   }

   public void setTest(String test)
   {
      this.test = test;
   }
}
 </pre><p>This a List or array of this Foo class would be represented in JSON like this:</p><pre class="programlisting">
 
 [{"foo":{"@test":"bill"}},{"foo":{"@test":"monica}"}}]
 
 </pre><p>It also expects this format for input</p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_Map"/>19.7. Maps of JAXB Objects</h2></div></div></div><p>
         RESTEasy will automatically
         marshal maps of JAXB objects to and from XML, JSON, Fastinfoset (or any other new JAXB mapper Restasy comes up with).
         Your parameter or method return type must be a generic with a String as the key and the JAXB object's type.
     </p><pre class="programlisting">
@XmlRootElement(namespace = "http://foo.com")
public static class Foo
{
   @XmlAttribute
   private String name;

   public Foo()
   {
   }

   public Foo(String name)
   {
      this.name = name;
   }

   public String getName()
   {
      return name;
   }
}

@Path("/map")
public static class MyResource
{
   @POST
   @Produces("application/xml")
   @Consumes("application/xml")
   public Map&lt;String, Foo&gt; post(Map&lt;String, Foo&gt; map)
   {
      Assert.assertEquals(2, map.size());
      Assert.assertNotNull(map.get("bill"));
      Assert.assertNotNull(map.get("monica"));
      Assert.assertEquals(map.get("bill").getName(), "bill");
      Assert.assertEquals(map.get("monica").getName(), "monica");
      return map;
   }
 }
 
 </pre><p>
      The above resource can publish and receive JAXB objects within a map.  By default, they are wrapped in a "map" element in the
      default namespace.  Also, each "map" element has zero or more "entry" elements with a "key" attribute.
   </p><pre class="programlisting">
 &lt;map&gt;
&lt;entry key="bill" xmlns="http://foo.com"&gt;
    &lt;foo name="bill"/&gt;
&lt;/entry&gt;
&lt;entry key="monica" xmlns="http://foo.com"&gt;
    &lt;foo name="monica"/&gt;
&lt;/entry&gt;
 &lt;/map&gt;
 
 </pre><p>You can change the namespace URI, namespace prefix and map, entry, and key element and attribute names by using the @org.jboss.resteasy.annotations.providers.jaxb.WrappedMap annotation on a parameter or method</p><pre class="programlisting">
 @Target({ElementType.PARAMETER, ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
 public @interface WrappedMap
 {
/**
 * map element name
 */
String map() default "map";

/**
 * entry element name *
 */
String entry() default "entry";

/**
 * entry's key attribute name
 */
String key() default "key";

String namespace() default "";

String prefix() default "";
 }
 </pre><p>So, if we wanted to output this XML</p><pre class="programlisting">
 &lt;hashmap&gt;
&lt;hashentry hashkey="bill" xmlns:foo="http://foo.com"&gt;
    &lt;foo:foo name="bill"/&gt;
&lt;/hashentry&gt;
 &lt;/map&gt;
 
 </pre><p>We would use the @WrappedMap annotation as follows: </p><pre class="programlisting">
@Path("/map")
public static class MyResource
{
   @GET
   @Produces("application/xml")
   @WrappedMap(map="hashmap", entry="hashentry", key="hashkey")
   public Map&lt;String, Foo&gt; get()
   {
      ...
      return map;
   }
 
 </pre><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="json_map"/>19.7.1. JSON and JAXB maps</h3></div></div></div><p>Resteasy supports using maps with JSON.  It encloses maps returned JAXB objects within a simple
    JSON map.  For example:</p><pre class="programlisting">
   @XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Foo
{
   @XmlAttribute
   private String test;

   public Foo()
   {
   }

   public Foo(String test)
   {
      this.test = test;
   }

   public String getTest()
   {
      return test;
   }

   public void setTest(String test)
   {
      this.test = test;
   }
}
 </pre><p>This a List or array of this Foo class would be represented in JSON like this:</p><pre class="programlisting">
 
 { "entry1" : {"foo":{"@test":"bill"}}, "entry2" : {"foo":{"@test":"monica}"}}}
 
 </pre><p>It also expects this format for input</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="JAXB_JSON_problems"/>19.7.2. Possible Problems with Jettison Provider</h3></div></div></div><p>
          If you have the resteasy-jackson-provider-xxx.jar in your classpath, the Jackson JSON provider
              will be triggered.  This will screw up code that is dependent on the Jettison JAXB/JSon provider.
              If you had been using the Jettison JAXB/Json providers, you must either remove
              Jackson from your WEB-INF/lib or classpath, or use the @NoJackson annotation on your JAXB classes.
      </p></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JAXB_INTERFACES"/>19.8. Interfaces, Abstract Classes, and JAXB</h2></div></div></div><p>
    Some objects models use abstract classes and interfaces heavily.  Unfortunately, JAXB doesn't work with interfaces
    that are root elements and RESTEasy can't unmarshal parameters that are interfaces or raw abstract classes because
    it doesn't have enough information to create a JAXBContext.  For example:
   </p><pre class="programlisting">
 public interface IFoo {}

 @XmlRootElement
 public class RealFoo implements IFoo {}

 @Path("/jaxb")
 public class MyResource {

@PUT
@Consumes("application/xml")
public void put(IFoo foo) {...}
 }
 </pre><p>
  In this example, you would get an error from RESTEasy of something like "Cannot find a MessageBodyReader for...".  This is because
  RESTEasy does not know that implementations of IFoo are JAXB classes and doesn't know how to create a JAXBContext for it.  As a workaround,
 RESTEasy allows you to use the JAXB annotation @XmlSeeAlso on the interface to correct the problem.  (NOTE, this will not work with manual, hand-coded JAXB).
</p><pre class="programlisting">
 @XmlSeeAlso(RealFoo.class)
 public interface IFoo {}
 </pre><p>
The extra @XmlSeeAlso on IFoo allows RESTEasy to create a JAXBContext that knows how to unmarshal RealFoo instances.
</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Atom"/>Chapter 20. Resteasy Atom Support</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#resteasy_atom">20.1. Resteasy Atom API and Provider</a></span></dt><dt><span class="sect1"><a href="#jaxb_atom">20.2. Using JAXB with the Atom Provider</a></span></dt></dl></div><p>
      From W3.org (http://tools.ietf.org/html/rfc4287):
   </p><p>
      "Atom is an XML-based document format that describes lists of related
      information known as "feeds". Feeds are composed of a number of
      items, known as "entries", each with an extensible set of attached
      metadata. For example, each entry has a title.

      The primary use case that Atom addresses is the syndication of Web
      content such as weblogs and news headlines to Web sites as well as
      directly to user agents."
   </p><p>
      Atom is the next-gen RSS feed. Although it is used primarily for the syndication of blogs and news, many
      are starting to use this format as the envelope for Web Services, for example, distributed notifications, job
      queues, or simply a nice format for sending or receiving data in bulk from a service.
   </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="resteasy_atom"/>20.1. Resteasy Atom API and Provider</h2></div></div></div><p>RESTEasy has defined a simple object model in Java to represent Atom and uses JAXB to marshal and unmarshal
         it. The
         main classes are in the org.jboss.resteasy.plugins.providers.atom package and are Feed, Entry, Content, and
         Link. If you
         look at the source, you'd see that these are annotated with JAXB annotations. The distribution contains
         the javadocs for this project and are a must to learn the model. Here is a simple example of sending
         an atom feed using the Resteasy API.
      </p><pre class="programlisting">
import org.jboss.resteasy.plugins.providers.atom.Content;
import org.jboss.resteasy.plugins.providers.atom.Entry;
import org.jboss.resteasy.plugins.providers.atom.Feed;
import org.jboss.resteasy.plugins.providers.atom.Link;
import org.jboss.resteasy.plugins.providers.atom.Person;

@Path("atom")
public class MyAtomService
{

   @GET
   @Path("feed")
   @Produces("application/atom+xml")
   public Feed getFeed() throws URISyntaxException
   {
      Feed feed = new Feed();
      feed.setId(new URI("http://example.com/42"));
      feed.setTitle("My Feed");
      feed.setUpdated(new Date());
      Link link = new Link();
      link.setHref(new URI("http://localhost"));
      link.setRel("edit");
      feed.getLinks().add(link);
      feed.getAuthors().add(new Person("Bill Burke"));
      Entry entry = new Entry();
      entry.setTitle("Hello World");
      Content content = new Content();
      content.setType(MediaType.TEXT_HTML_TYPE);
      content.setText("Nothing much");
      entry.setContent(content);
      feed.getEntries().add(entry);
      return feed;
   }
}

      </pre><p>Because Resteasy's atom provider is JAXB based, you are not limited to sending atom objects using XML.
         You can automatically re-use all the other JAXB providers that Resteasy has like JSON and fastinfoset.
         All you have to do is have "atom+" in front of the main subtype. i.e. @Produces("application/atom+json") or
         @Consumes("application/atom+fastinfoset")
      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="jaxb_atom"/>20.2. Using JAXB with the Atom Provider</h2></div></div></div><p>
         The org.jboss.resteasy.plugins.providers.atom.Content class allows you to unmarshal and marshal JAXB
         annotated objects that are the body of the content. Here's an example of sending an Entry with
         a Customer object attached as the body of the entry's content.
      </p><pre class="programlisting">
@XmlRootElement(namespace = "http://jboss.org/Customer")
@XmlAccessorType(XmlAccessType.FIELD)
public class Customer
{
   @XmlElement
   private String name;

   public Customer()
   {
   }

   public Customer(String name)
   {
      this.name = name;
   }

   public String getName()
   {
      return name;
   }
}

@Path("atom")
public static class AtomServer
{
   @GET
   @Path("entry")
   @Produces("application/atom+xml")
   public Entry getEntry()
   {
      Entry entry = new Entry();
      entry.setTitle("Hello World");
      Content content = new Content();
      content.setJAXBObject(new Customer("bill"));
      entry.setContent(content);
      return entry;
   }
}
</pre><p>
         The Content.setJAXBObject() method is used to tell the content object you are sending back
         a Java JAXB object and want it marshalled appropriately. If you are using a different base
         format other than XML, i.e. "application/atom+json", this attached JAXB object will be marshalled
         into that same format.
      </p><p>
         If you have an atom document as your input, you can also extract JAXB objects from Content using the
         Content.getJAXBObject(Class clazz) method. Here is an example of an input atom document and extracting
         a Customer object from the content.
      </p><pre class="programlisting">
@Path("atom")
public static class AtomServer
{
   @PUT
   @Path("entry")
   @Produces("application/atom+xml")
   public void putCustomer(Entry entry)
   {
      Content content = entry.getContent();
      Customer cust = content.getJAXBObject(Customer.class);
   }
}
</pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Abdera"/>Chapter 21. Atom support through Apache Abdera</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#Abdera and Maven">21.1. Abdera and Maven</a></span></dt><dt><span class="sect1"><a href="#using_abdera">21.2. Using the Abdera Provider</a></span></dt></dl></div><p>
   Resteasy provides support for Apache Abdera, an implementation of the Atom protocol and data format.
   http://incubator.apache.org/abdera/
</p><p>
   Abdera is a full-fledged Atom server. Resteasy only supports integration with JAX-RS for Atom data format
   marshalling and unmarshalling to and from the Feed and Entry interface types in Abdera. Here's a simple example:
</p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Abdera and Maven"/>21.1. Abdera and Maven</h2></div></div></div><p>The Abdera provider is not included with the Resteasy distribution. To include the Abdera provider
      in your WAR poms, include the following. Please change the version to be the version of resteasy you
      are working with. Also, Resteasy may be coded to pick up an older version of Abdera than what you want. You're
      on your own with fixing this one, sorry.
   </p><pre class="programlisting">
   &lt;repository&gt;
      &lt;id&gt;jboss&lt;/id&gt;
      &lt;url&gt;&gt;http://repository.jboss.org/nexus/content/groups/public/&lt;/url&gt;
   &lt;/repository&gt;

      ...
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;abdera-atom-provider&lt;/artifactId&gt;
      &lt;version&gt;...version...&lt;/version&gt;
   &lt;/dependency&gt;
</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="using_abdera"/>21.2. Using the Abdera Provider</h2></div></div></div><pre class="programlisting">
import org.apache.abdera.Abdera;
import org.apache.abdera.factory.Factory;
import org.apache.abdera.model.Entry;
import org.apache.abdera.model.Feed;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.PutMethod;
import org.apache.commons.httpclient.methods.StringRequestEntity;
import org.jboss.resteasy.plugins.providers.atom.AbderaEntryProvider;
import org.jboss.resteasy.plugins.providers.atom.AbderaFeedProvider;
import org.jboss.resteasy.test.BaseResourceTest;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.UriInfo;
import javax.xml.bind.JAXBContext;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.Date;

/**
 * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
 * @version $Revision: 1 $
 */
public class AbderaTest extends BaseResourceTest
{

   @Path("atom")
   public static class MyResource
   {
      private static final Abdera abdera = new Abdera();

      @GET
      @Path("feed")
      @Produces(MediaType.APPLICATION_ATOM_XML)
      public Feed getFeed(@Context UriInfo uri) throws Exception
      {
         Factory factory = abdera.getFactory();
         Assert.assertNotNull(factory);
         Feed feed = abdera.getFactory().newFeed();
         feed.setId("tag:example.org,2007:/foo");
         feed.setTitle("Test Feed");
         feed.setSubtitle("Feed subtitle");
         feed.setUpdated(new Date());
         feed.addAuthor("James Snell");
         feed.addLink("http://example.com");


         Entry entry = feed.addEntry();
         entry.setId("tag:example.org,2007:/foo/entries/1");
         entry.setTitle("Entry title");
         entry.setUpdated(new Date());
         entry.setPublished(new Date());
         entry.addLink(uri.getRequestUri().toString());

         Customer cust = new Customer("bill");

         JAXBContext ctx = JAXBContext.newInstance(Customer.class);
         StringWriter writer = new StringWriter();
         ctx.createMarshaller().marshal(cust, writer);
         entry.setContent(writer.toString(), "application/xml");
         return feed;

      }

      @PUT
      @Path("feed")
      @Consumes(MediaType.APPLICATION_ATOM_XML)
      public void putFeed(Feed feed) throws Exception
      {
         String content = feed.getEntries().get(0).getContent();
         JAXBContext ctx = JAXBContext.newInstance(Customer.class);
         Customer cust = (Customer) ctx.createUnmarshaller().unmarshal(new StringReader(content));
         Assert.assertEquals("bill", cust.getName());

      }

      @GET
      @Path("entry")
      @Produces(MediaType.APPLICATION_ATOM_XML)
      public Entry getEntry(@Context UriInfo uri) throws Exception
      {
         Entry entry = abdera.getFactory().newEntry();
         entry.setId("tag:example.org,2007:/foo/entries/1");
         entry.setTitle("Entry title");
         entry.setUpdated(new Date());
         entry.setPublished(new Date());
         entry.addLink(uri.getRequestUri().toString());

         Customer cust = new Customer("bill");

         JAXBContext ctx = JAXBContext.newInstance(Customer.class);
         StringWriter writer = new StringWriter();
         ctx.createMarshaller().marshal(cust, writer);
         entry.setContent(writer.toString(), "application/xml");
         return entry;

      }

      @PUT
      @Path("entry")
      @Consumes(MediaType.APPLICATION_ATOM_XML)
      public void putFeed(Entry entry) throws Exception
      {
         String content = entry.getContent();
         JAXBContext ctx = JAXBContext.newInstance(Customer.class);
         Customer cust = (Customer) ctx.createUnmarshaller().unmarshal(new StringReader(content));
         Assert.assertEquals("bill", cust.getName());

      }
   }

   @Before
   public void setUp() throws Exception
   {
      dispatcher.getProviderFactory().registerProvider(AbderaFeedProvider.class);
      dispatcher.getProviderFactory().registerProvider(AbderaEntryProvider.class);
      dispatcher.getRegistry().addPerRequestResource(MyResource.class);
   }

   @Test
   public void testAbderaFeed() throws Exception
   {
      HttpClient client = new HttpClient();
      GetMethod method = new GetMethod("http://localhost:8081/atom/feed");
      int status = client.executeMethod(method);
      Assert.assertEquals(200, status);
      String str = method.getResponseBodyAsString();

      PutMethod put = new PutMethod("http://localhost:8081/atom/feed");
      put.setRequestEntity(new StringRequestEntity(str, MediaType.APPLICATION_ATOM_XML, null));
      status = client.executeMethod(put);
      Assert.assertEquals(200, status);

   }

   @Test
   public void testAbderaEntry() throws Exception
   {
      HttpClient client = new HttpClient();
      GetMethod method = new GetMethod("http://localhost:8081/atom/entry");
      int status = client.executeMethod(method);
      Assert.assertEquals(200, status);
      String str = method.getResponseBodyAsString();

      PutMethod put = new PutMethod("http://localhost:8081/atom/entry");
      put.setRequestEntity(new StringRequestEntity(str, MediaType.APPLICATION_ATOM_XML, null));
      status = client.executeMethod(put);
      Assert.assertEquals(200, status);
   }
}

   </pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="json"/>Chapter 22. JSON Support via Jackson</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#Possible_Jackson_Problems">22.1. Possible Conflict With JAXB Provider</a></span></dt></dl></div><p>Besides the Jettision JAXB adapter for JSON, Resteasy also support integration with the Jackson project.
        Many users find the output from Jackson much much nicer than the Badger format or Mapped format provided by
        Jettison.
        Jackson lives at http://jackson.codehaus.org. It allows you to easily marshal Java objects to and from JSON.
        It has a Java Bean based model as well as JAXB like APIs. Resteasy integrates with the JavaBean model as
        described
        at this url: http://jackson.codehaus.org/Tutorial.
    </p><p>While Jackson does come with its own JAX-RS integration. Resteasy expanded it a little. To include
        it within your project, just add this maven dependency to your build.
    </p><pre class="programlisting">
    &lt;repository&gt;
       &lt;id&gt;jboss&lt;/id&gt;
       &lt;url&gt;&gt;http://repository.jboss.org/nexus/content/groups/public/&lt;/url&gt;
    &lt;/repository&gt;

       ...
    &lt;dependency&gt;
       &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
       &lt;artifactId&gt;resteasy-jackson-provider&lt;/artifactId&gt;
       &lt;version&gt;2.2.1.GA&lt;/version&gt;
    &lt;/dependency&gt;
 </pre><p>The first extra piece that Resteasy added to the integration was
        to support "application/*+json". Jackson would only accept "application/json" and "text/json" as valid
        media types. This allows you to create json-based media types and still
        let Jackson marshal things for you. For example:
    </p><pre class="programlisting">
        
@Path("/customers")
public class MyService {

   @GET
   @Produces("application/vnd.customer+json")
   public Customer[] getCustomers() {}
}

    </pre><p>Another problem that occurs is when you are using the Resteasy JAXB providers alongside Jackson.
        You may want to use Jettision and JAXB to output your JSON instead of Jackson. In this case, you must
        either not install the Jackson provider, or use the annotation
        @org.jboss.resteasy.annotations.providers.NoJackson
        on your JAXB annotated classes. For example:
    </p><pre class="programlisting">
        

    @XmlRootElement
    @NoJackson
    public class Customer {...}

    @Path("/customers")
    public class MyService {

       @GET
       @Produces("application/vnd.customer+json")
       public Customer[] getCustomers() {}
    }
    
    </pre><p>
        If you can't annotate the JAXB class with @NoJackson, then you can
        use the annotation on a method parameter. For example:
    </p><pre class="programlisting">
        

        @XmlRootElement
        public class Customer {...}

        @Path("/customers")
        public class MyService {

           @GET
           @Produces("application/vnd.customer+json")
           @NoJackson
           public Customer[] getCustomers() {}

           @POST
           @Consumes("application/vnd.customer+json")
           public void createCustomer(@NoJackson Customer[] customers) {...}
        }
        
    </pre><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Possible_Jackson_Problems"/>22.1. Possible Conflict With JAXB Provider</h2></div></div></div><p>
            If your Jackson classes are annotated with JAXB annotations and you have the resteasy-jaxb-provider in your
            classpath, you may trigger the Jettision JAXB marshalling code. To turn off the JAXB json marshaller
            use the @org.jboss.resteasy.annotations.providers.jaxb.IgnoreMediaTypes("application/*+json") on your
            classes.
        </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Multipart"/>Chapter 23. Multipart Providers</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#MultipartInput">23.1. Input with multipart/mixed</a></span></dt><dt><span class="sect1"><a href="#multipart_list">23.2. java.util.List with multipart data</a></span></dt><dt><span class="sect1"><a href="#MultipartFormData">23.3. Input with multipart/form-data</a></span></dt><dt><span class="sect1"><a href="#multipart_map">23.4. java.util.Map with multipart/form-data</a></span></dt><dt><span class="sect1"><a href="#MultipartRelated">23.5. Input with multipart/related</a></span></dt><dt><span class="sect1"><a href="#multipart_output">23.6. Output with multipart</a></span></dt><dt><span class="sect1"><a href="#multipart_list_output">23.7. Multipart Output with java.util.List</a></span></dt><dt><span class="sect1"><a href="#multipart_formdata_output">23.8. Output with multipart/form-data</a></span></dt><dt><span class="sect1"><a href="#multipart_map_output">23.9. Multipart FormData Output with java.util.Map</a></span></dt><dt><span class="sect1"><a href="#multipart_related_output">23.10. Output with multipart/related</a></span></dt><dt><span class="sect1"><a href="#multipartform_annotation">23.11. @MultipartForm and POJOs</a></span></dt><dt><span class="sect1"><a href="#xop_with_multipart_related">23.12. XML-binary Optimized Packaging (Xop)</a></span></dt><dt><span class="sect1"><a href="#multipart_parsing_note">23.13. Note about multipart parsing and working with other frameworks</a></span></dt><dt><span class="sect1"><a href="#multipart_overwrite_default_content_type">23.14. Overwriting the default fallback content type for multipart messages</a></span></dt></dl></div><p>Resteasy has rich support for the "multipart/*" and "multipart/form-data" mime types.  The multipart mime
      format is used to pass lists of content bodies.  Multiple content bodies are embedded in one message.
      "multipart/form-data" is often found in web application HTML Form documents and is generally used to
      upload files.  The form-data format is the same as other multipart formats, except that each inlined piece
      of content has a name associated with it.
    </p><p>RESTEasy provides
   a custom API for reading and writing multipart types as well as marshalling arbitrary List (for any multipart type)
      and Map (multipart/form-data only)
   objects</p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="MultipartInput"/>23.1. Input with multipart/mixed</h2></div></div></div><p>When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in any
      multipart mime type.  org.jboss.resteasy.plugins.providers.multipart.MultipartInput</p><pre class="programlisting">
package org.jboss.resteasy.plugins.providers.multipart;

public interface MultipartInput
{
   List&lt;InputPart&gt; getParts();

   String getPreamble();
}

public interface InputPart
{
   MultivaluedMap&lt;String, String&gt; getHeaders();

   String getBodyAsString();

   &lt;T&gt; T getBody(Class&lt;T&gt; type, Type genericType) throws IOException;

   &lt;T&gt; T getBody(org.jboss.resteasy.util.GenericType&lt;T&gt; type) throws IOException;

   MediaType getMediaType();

   boolean isContentTypeFromMessage();
}
      </pre><p>MultipartInput is a simple interface that allows you to get access to each part of the multipart message.
      Each part is represented by an InputPart interface. Each part has a set of headers associated with it
      You can unmarshall the part by calling one of the getBody() methods.  The Type genericType parameter can be null,
      but the Class type parameter must be set.  Resteasy will find a MessageBodyReader based on the media type
      of the part as well as the type information you pass in.  The following piece of code is unmarshalling
      parts which are XML into a JAXB annotated class called Customer.
      </p><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(MultipartInput input)
      {
         List&lt;Customer&gt; customers = new ArrayList...;
         for (InputPart part : input.getParts())
         {
            Customer cust = part.getBody(Customer.class, null);
            customers.add(cust);
         }
      }
   }
</pre><p>
         Sometimes you may want to unmarshall a body part that is sensitive to generic type metadata.  In this case
         you can use the org.jboss.resteasy.util.GenericType class.  Here's an example of unmarshalling a type that
         is sensitive to generic type metadata.
      </p><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(MultipartInput input)
      {
         for (InputPart part : input.getParts())
         {
            List&lt;Customer&gt; cust = part.getBody(new GenericType&gt;List&gt;Customer&lt;&lt;() {});
         }
      }
   }

</pre><p>
         Use of GenericType is required because it is really the only way to obtain generic type information at runtime.
      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_list"/>23.2. java.util.List with multipart data</h2></div></div></div><p>If your body parts are uniform, you do not have to manually unmarshall each and every part.
      You can just provide a java.util.List as your input parameter.  It must have the type it is
      unmarshalling with the generic parameter of the List type declaration.  Here's an example again
      of unmarshalling a list of customers.</p><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(List&lt;Customer&gt; customers)
      {
         ...
      }
   }

</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="MultipartFormData"/>23.3. Input with multipart/form-data</h2></div></div></div><p>When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in
      multipart/form-data mime type.  "multipart/form-data" is often found in web application HTML Form documents and is generally used to
      upload files.  The form-data format is the same as other multipart formats, except that each inlined piece
      of content has a name associated with it.  The interface used for form-data input is
         org.jboss.resteasy.plugins.providers.multipart.MultipartFormDataInput</p><pre class="programlisting">
public interface MultipartFormDataInput extends MultipartInput
{
   @Deprecated
   Map&lt;String, InputPart&gt; getFormData();

   Map&lt;String, List&lt;InputPart&gt;&gt; getFormDataMap();

   &lt;T&gt; T getFormDataPart(String key, Class&lt;T&gt; rawType, Type genericType) throws IOException;

   &lt;T&gt; T getFormDataPart(String key, GenericType&lt;T&gt; type) throws IOException;
}
</pre><p>
         It works in much the same way as MultipartInput described earlier in this chapter.
      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_map"/>23.4. java.util.Map with multipart/form-data</h2></div></div></div><p>With form-data, if your body parts are uniform, you do not have to manually unmarshall each and every part.
      You can just provide a java.util.Map as your input parameter.  It must have the type it is
      unmarshalling with the generic parameter of the List type declaration.  Here's an example of
      of unmarshalling a Map of Customer objects which are JAXB annotated classes.</p><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/form-data")
      public void put(Map&lt;String, Customer&gt; customers)
      {
         ...
      }
   }

</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="MultipartRelated"/>23.5. Input with multipart/related</h2></div></div></div><p>When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in
      multipart/related mime type. A multipart/related is used to indicate that message parts
      should not be considered individually but rather as parts of an aggregate whole. One example
      usage for multipart/related is to send a web page complete with images in a single message.
      Every multipart/related message has a root/start part that references the other parts of the message.
      The parts are identified by their "Content-ID" headers. multipart/related is defined by RFC 2387.
      The interface used for related input is org.jboss.resteasy.plugins.providers.multipart.MultipartRelatedInput</p><pre class="programlisting">
public interface MultipartRelatedInput extends MultipartInput
{
   String getType();

   String getStart();

   String getStartInfo();

   InputPart getRootPart();

   Map&lt;String, InputPart&gt; getRelatedMap();
}
</pre><p>
         It works in much the same way as MultipartInput described earlier in this chapter.
      </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_output"/>23.6. Output with multipart</h2></div></div></div><p>RESTEasy provides a simple API to output multipart data.</p><pre class="programlisting">
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartOutput
{
   public OutputPart addPart(Object entity, MediaType mediaType)

   public OutputPart addPart(Object entity, GenericType type, MediaType mediaType)

   public OutputPart addPart(Object entity, Class type, Type genericType, MediaType mediaType)

   public List&lt;OutputPart&gt; getParts()

   public String getBoundary()

   public void setBoundary(String boundary)
}

public class OutputPart
{
   public MultivaluedMap&lt;String, Object&gt; getHeaders()

   public Object getEntity()

   public Class getType()

   public Type getGenericType()

   public MediaType getMediaType()
}


</pre><p>When you want to output multipart data it is as simple as creating a MultipartOutput object
      and calling addPart() methods.  Resteasy will automatically find a MessageBodyWriter
      to marshall your entity objects.  Like MultipartInput, sometimes you may have marshalling
      which is sensitive to generic type metadata.  In that case, use GenericType.  Most of the time though
      passing in an Object and its MediaType is enough.  In the example below, we are sending
      back a "multipart/mixed" format back to the calling client.  The parts are
      Customer objects which are JAXB annotated and will be marshalling into "application/xml".</p><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/mixed")
      public MultipartOutput get()
      {
         MultipartOutput output = new MultipartOutput();
         output.addPart(new Customer("bill"), MediaType.APPLICATION_XML_TYPE);
         output.addPart(new Customer("monica"), MediaType.APPLICATION_XML_TYPE);
         return output;
      }

</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_list_output"/>23.7. Multipart Output with java.util.List</h2></div></div></div><p>If your body parts are uniform, you do not have to manually marshall each and every part or even
         use a MultipartOutput object..
      You can just provide a java.util.List.  It must have the generic type it is
      marshalling with the generic parameter of the List type declaration.  You must also annotate the method
         with the @PartType annotation to specify what media type each part is.  Here's an example
      of sending back a list of customers back to a client.  The customers are JAXB objects</p><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/mixed")
      @PartType("application/xml")
      public List&lt;Customer&gt; get()
      {
         ...
      }
   }

</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_formdata_output"/>23.8. Output with multipart/form-data</h2></div></div></div><p>RESTEasy provides a simple API to output multipart/form-data.</p><pre class="programlisting">
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartFormDataOutput extends MultipartOutput
{
   public OutputPart addFormData(String key, Object entity, MediaType mediaType)

   public OutputPart addFormData(String key, Object entity, GenericType type, MediaType mediaType)

   public OutputPart addFormData(String key, Object entity, Class type, Type genericType, MediaType mediaType)

   public Map&lt;String, OutputPart&gt; getFormData()
}

</pre><p>When you want to output multipart/form-data it is as simple as creating a MultipartFormDataOutput object
      and calling addFormData() methods.  Resteasy will automatically find a MessageBodyWriter
      to marshall your entity objects.  Like MultipartInput, sometimes you may have marshalling
      which is sensitive to generic type metadata.  In that case, use GenericType.  Most of the time though
      passing in an Object and its MediaType is enough.  In the example below, we are sending
      back a "multipart/form-data" format back to the calling client.  The parts are
      Customer objects which are JAXB annotated and will be marshalling into "application/xml".</p><pre class="programlisting">
   @Path("/form")
   public class MyService
   {
      @GET
      @Produces("multipart/form-data")
      public MultipartFormDataOutput get()
      {
         MultipartFormDataOutput output = new MultipartFormDataOutput();
         output.addPart("bill", new Customer("bill"), MediaType.APPLICATION_XML_TYPE);
         output.addPart("monica", new Customer("monica"), MediaType.APPLICATION_XML_TYPE);
         return output;
      }

</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_map_output"/>23.9. Multipart FormData Output with java.util.Map</h2></div></div></div><p>If your body parts are uniform, you do not have to manually marshall each and every part or even
         use a MultipartFormDataOutput object..
      You can just provide a java.util.Map.  It must have the generic type it is
      marshalling with the generic parameter of the Map type declaration.  You must also annotate the method
         with the @PartType annotation to specify what media type each part is.  Here's an example
      of sending back a list of customers back to a client.  The customers are JAXB objects</p><pre class="programlisting">
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/form-data")
      @PartType("application/xml")
      public Map&lt;String, Customer&gt; get()
      {
         ...
      }
   }

</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_related_output"/>23.10. Output with multipart/related</h2></div></div></div><p>RESTEasy provides a simple API to output multipart/related.</p><pre class="programlisting">
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartRelatedOutput extends MultipartOutput
{
   public OutputPart getRootPart()

   public OutputPart addPart(Object entity, MediaType mediaType,
      String contentId, String contentTransferEncoding)

   public String getStartInfo()

   public void setStartInfo(String startInfo)
}

</pre><p>When you want to output multipart/related it is as simple as creating a MultipartRelatedOutput object
      and calling addPart() methods. The first added part will be used as the root part of the multipart/related
      message.
      Resteasy will automatically find a MessageBodyWriter to marshall your entity objects. Like MultipartInput,
      sometimes you may have marshalling which is sensitive to generic type metadata. In that case, use
      GenericType.  Most of the time though passing in an Object and its MediaType is enough.  In the example
      below, we are sending back a "multipart/related" format back to the calling client. We are sending a
      html with 2 images.</p><pre class="programlisting">
@Path("/related")
public class MyService
{
   @GET
   @Produces("multipart/related")
   public MultipartRelatedOutput get()
   {
      MultipartRelatedOutput output = new MultipartRelatedOutput();
      output.setStartInfo("text/html");

      Map&lt;String, String&gt; mediaTypeParameters = new LinkedHashMap&lt;String, String&gt;();
      mediaTypeParameters.put("charset", "UTF-8");
      mediaTypeParameters.put("type", "text/html");
      output
         .addPart(
            "&lt;html&gt;&lt;body&gt;\n"
            + "This is me: &lt;img src='cid:http://example.org/me.png' /&gt;\n"
            + "&lt;br /&gt;This is you: &lt;img src='cid:http://example.org/you.png' /&gt;\n"
            + "&lt;/body&gt;&lt;/html&gt;",
            new MediaType("text", "html", mediaTypeParameters),
            "&lt;mymessage.xml@example.org&gt;", "8bit");
      output.addPart("// binary octets for me png",
            new MediaType("image", "png"), "&lt;http://example.org/me.png&gt;",
            "binary");
      output.addPart("// binary octets for you png", new MediaType(
            "image", "png"),
            "&lt;http://example.org/you.png&gt;", "binary");
      client.putRelated(output);
      return output;
   }
}
</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipartform_annotation"/>23.11. @MultipartForm and POJOs</h2></div></div></div><p>If you have a exact knowledge of your multipart/form-data packets, you can map
      them to and from a POJO class to and from multipart/form-data using the
      @org.jboss.resteasy.annotations.providers.multipart.MultipartForm annotation
      and the JAX-RS @FormParam annotation.  You simple define a POJO with
      at least a default constructor and annotate its fields and/or properties
      with @FormParams.  These @FormParams must also be annotated with
      @org.jboss.resteasy.annotations.providers.multipart.PartType if you
      are doing output.  For example:</p><pre class="programlisting">
   public class CustomerProblemForm {
      @FormParam("customer")
      @PartType("application/xml")
      private Customer customer;

      @FormParam("problem")
      @PartType("text/plain")
      private String problem;

      public Customer getCustomer() { return customer; }
      public void setCustomer(Customer cust) { this.customer = cust; }
      public String getProblem() { return problem; }
      public void setProblem(String problem) { this.problem = problem; }
   }
</pre><p>After defining your POJO class you can then use it to represent multipart/form-data.  Here's
      an example of sending a CustomerProblemForm using the RESTEasy client framework</p><pre class="programlisting">
   @Path("portal")
   public interface CustomerPortal {

      @Path("issues/{id}")
      @Consumes("multipart/form-data")
      @PUT
      public void putProblem(@MultipartForm CustomerProblemForm,
                             @PathParam("id") int id);
   }

   {
       CustomerPortal portal = ProxyFactory.create(CustomerPortal.class, "http://example.com");
       CustomerProblemForm form = new CustomerProblemForm();
       form.setCustomer(...);
       form.setProblem(...);

       portal.putProblem(form, 333);
   }
</pre><p>You see that the @MultipartForm annotation was used to tell RESTEasy that the object has @FormParam
      and that it should be marshalled from that.  You can also use the same object to receive multipart data.
      Here is an example of the server side counterpart of our customer portal.</p><pre class="programlisting">
   @Path("portal")
   public class CustomerPortalServer {

      @Path("issues/{id})
      @Consumes("multipart/form-data")
      @PUT
      public void putIssue(@MultipartForm CustoemrProblemForm,
                           @PathParam("id") int id) {
         ... write to database...
      }
   }
</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="xop_with_multipart_related"/>23.12. XML-binary Optimized Packaging (Xop)</h2></div></div></div><p>RESTEasy supports Xop messages packaged as multipart/related. What does this mean? If you have a JAXB
      annotated POJO that also holds some binary content you may choose to send it in such a way where the binary
      does not need to be encoded in any way (neither base64 neither hex). This results in faster transport while
      still using the convenient POJO. More about Xop can be read here:
      <a href="#">http://www.w3.org/TR/xop10/</a>. Now lets see an example:</p><p>First we have a JAXB annotated POJO to work with. @XmlMimeType tells JAXB the mime type of the binary
      content (its not required to do XOP packaging but it is recommended to be set if you know the exact type):</p><pre class="programlisting">
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public static class Xop {
  private Customer bill;

  private Customer monica;

  @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
  private byte[] myBinary;

  @XmlMimeType(MediaType.APPLICATION_OCTET_STREAM)
  private DataHandler myDataHandler;

  // methods, other fields ...
}
</pre><p>In the above POJO myBinary and myDataHandler will be processed as binary attachments while the whole Xop
      object will be sent as xml (in the places of the binaries only their references will be generated).
      javax.activation.DataHandler is the most general supported type so if you need an java.io.InputStream or a
      javax.activation.DataSource you need to go with the DataHandler. Some other special types are supported too:
      java.awt.Image and javax.xml.transform.Source. Let's assume that Customer is also JAXB friendly POJO in the
      above example (of course it can also have binary parts). Now lets see a an example Java client that sends this:</p><pre class="programlisting">
// our client interface:
@Path("mime")
public static interface MultipartClient {
  @Path("xop")
  @PUT
  @Consumes(MediaType.MULTIPART_RELATED)
  public void putXop(@XopWithMultipartRelated Xop bean);
}

// Somewhere using it:
{
  MultipartClient client = ProxyFactory.create(MultipartClient.class,
    "http://www.example.org");
  Xop xop = new Xop(new Customer("bill"), new Customer("monica"),
    "Hello Xop World!".getBytes("UTF-8"),
    new DataHandler(new ByteArrayDataSource("Hello Xop World!".getBytes("UTF-8"),
    MediaType.APPLICATION_OCTET_STREAM)));
  client.putXop(xop);
}
</pre><p>We used @Consumes(MediaType.MULTIPART_RELATED) to tell RESTEasy that we want to send multipart/related
	packages (thats the container format that will hold our Xop message). We used @XopWithMultipartRelated to tell
	RESTEasy that we want to make Xop messages. So we have a POJO and a client service that is willing to send it. All
	we need now a server that can read it:</p><pre class="programlisting">
@Path("/mime")
public class XopService {
  @PUT
  @Path("xop")
  @Consumes(MediaType.MULTIPART_RELATED)
  public void putXopWithMultipartRelated(@XopWithMultipartRelated Xop xop) {
    // do very important things here
  }
}
</pre><p>We used @Consumes(MediaType.MULTIPART_RELATED) to tell RESTEasy that we want to read multipart/related
	packages. We used @XopWithMultipartRelated to tell RESTEasy that we want to read Xop messages. Of course we could
	also produce Xop return values but we would than also need to annotate that and use a Produce annotation, too.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_parsing_note"/>23.13. Note about multipart parsing and working with other frameworks</h2></div></div></div><p>There are a lot of frameworks doing multipart parsing automatically with the help of filters and interceptors.
      Like org.jboss.seam.web.MultipartFilter in Seam or org.springframework.web.multipart.MultipartResolver in Spring.
      However the incoming multipart request stream can be parsed only once. Resteasy users working with multipart should
      make sure that nothing parses the stream before Resteasy gets it.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="multipart_overwrite_default_content_type"/>23.14. Overwriting the default fallback content type for multipart messages</h2></div></div></div><p>By default if no Content-Type header is present in a part, "text/plain; charset=us-ascii" is used as fallback.
      This is the value defined by the MIME RFC. However for example some web clients (like most, if not all, web browsers)
      do not send Content-Type headers for all fields in a multipart/form-data request (only for the file parts). This can
      cause character encoding and unmarshalling errors on the server side. To correct this there is an option to define an
      other, non-rfc compliant fallback value. This can be done dynamicly per request with the PreProcessInterceptor
      infrastructure of RESTEasy. In the following example we will set "*/*; charset=UTF-8" as the new default fallback:
</p><pre class="programlisting">
import org.jboss.resteasy.plugins.providers.multipart.InputPart;

@Provider
@ServerInterceptor
public class ContentTypeSetterPreProcessorInterceptor implements
		PreProcessInterceptor {

	public ServerResponse preProcess(HttpRequest request,
			ResourceMethod method) throws Failure, WebApplicationException {
		request.setAttribute(InputPart.DEFAULT_CONTENT_TYPE_PROPERTY,
				"*/*; charset=UTF-8");
		return null;
	}

}
</pre><p>
      </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Built_in_YAML_Provider"/>Chapter 24. YAML Provider</h2></div></div></div><p>

      Since 2.2.1.GA  release, resteasy comes with built in support for YAML using the SnakeYAML library. To enable YAML support,
      you need to drop in the SnakeYaml 1.8 jar in RestEASY's classpath.
   </p><p>


   </p><p>

      SnakeYaml jar file can either be downloaded from Google code at
       http://code.google.com/p/snakeyaml/downloads/list
   </p><p>

      Or if you use maven, the SnakeYaml jar is available through SonaType public repositories and included using this
      dependency:
   </p><p>

 </p><pre class="programlisting">
 &lt;dependency&gt;
&lt;groupId&gt;org.yaml&lt;/groupId&gt;
&lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;
&lt;version&gt;1.8&lt;/version&gt;
 &lt;/dependency&gt;
      </pre><p>
   </p><p>

      When starting resteasy look out in the logs for a line stating that the YamlProvider has been added - this
      indicates that resteasy has found the Jyaml jar:
   </p><p>

      2877 Main INFO org.jboss.resteasy.plugins.providers.RegisterBuiltin - Adding YamlProvider
   </p><p>


   </p><p>

      The Yaml provider recognises three mime types:
   </p><p>

      </p><div class="itemizedlist"><ul><li>
            text/x-yaml
         </li><li>
            text/yaml
         </li><li>
            application/x-yaml
         </li></ul></div><p>

   </p><p>


   </p><p>

      This is an example of how to use Yaml in a resource method.
   </p><p>

 </p><pre class="programlisting">
 import javax.ws.rs.Consumes;
 import javax.ws.rs.GET;
 import javax.ws.rs.Path;
 import javax.ws.rs.Produces;

 @Path("/yaml")
 public class YamlResource
 {

@GET
@Produces("text/x-yaml")
public MyObject getMyObject() {
   return createMyObject();
}
...
 }
 </pre><p>
   </p><p>

   </p><p>

   </p><p>


   </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="StringConverter"/>Chapter 25. String marshalling for String based @*Param</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#StringConverterInterface">25.1. StringConverter</a></span></dt><dt><span class="sect1"><a href="#StringParamUnmarshaller">25.2. StringParamUnmarshaller</a></span></dt></dl></div><p>@PathParam, @QueryParam, @MatrixParam, @FormParam, and @HeaderParam are represented as strings in a raw
      HTTP request. The specification says that these types of injected parameters can be converted to objects
      if these objects have a valueOf(String) static method or a constructor that takes one String parameter.
      What if you have a class where valueOf() or this string constructor doesn't exist or is inappropriate for
      an HTTP request? Resteasy has 2 proprietary @Provider interfaces that you can plug in:
   </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="StringConverterInterface"/>25.1. StringConverter</h2></div></div></div><pre class="programlisting">

package org.jboss.resteasy.spi;

public interface StringConverter&lt;T&gt;
{
   T fromString(String str);
   String toString(T value);
}



   </pre><p>You implement this interface to provide your own custom string marshalling. It is registered
      within your web.xml under the resteasy.providers context-param (See Installation and Configuration chapter).
      You can do it manually by calling the ResteasyProviderFactory.addStringConverter() method. Here's a simple
      example of using a StringConverter:
   </p><pre class="programlisting">
   import org.jboss.resteasy.client.ProxyFactory;
   import org.jboss.resteasy.spi.StringConverter;
   import org.jboss.resteasy.test.BaseResourceTest;
   import org.junit.Assert;
   import org.junit.Before;
   import org.junit.Test;

   import javax.ws.rs.HeaderParam;
   import javax.ws.rs.MatrixParam;
   import javax.ws.rs.PUT;
   import javax.ws.rs.Path;
   import javax.ws.rs.PathParam;
   import javax.ws.rs.QueryParam;
   import javax.ws.rs.ext.Provider;

   public class StringConverterTest extends BaseResourceTest
   {
      public static class POJO
      {
         private String name;

         public String getName()
         {
            return name;
         }

         public void setName(String name)
         {
            this.name = name;
         }
      }

      @Provider
      public static class POJOConverter implements StringConverter&lt;POJO&gt;
      {
         public POJO fromString(String str)
         {
            System.out.println("FROM STRNG: " + str);
            POJO pojo = new POJO();
            pojo.setName(str);
            return pojo;
         }

         public String toString(POJO value)
         {
            return value.getName();
         }
      }

      @Path("/")
      public static class MyResource
      {
         @Path("{pojo}")
         @PUT
         public void put(@QueryParam("pojo")POJO q, @PathParam("pojo")POJO pp,
                         @MatrixParam("pojo")POJO mp, @HeaderParam("pojo")POJO hp)
         {
            Assert.assertEquals(q.getName(), "pojo");
            Assert.assertEquals(pp.getName(), "pojo");
            Assert.assertEquals(mp.getName(), "pojo");
            Assert.assertEquals(hp.getName(), "pojo");
         }
      }

      @Before
      public void setUp() throws Exception
      {
         dispatcher.getProviderFactory().addStringConverter(POJOConverter.class);
         dispatcher.getRegistry().addPerRequestResource(MyResource.class);
      }

      @Path("/")
      public static interface MyClient
      {
         @Path("{pojo}")
         @PUT
         void put(@QueryParam("pojo")POJO q, @PathParam("pojo")POJO pp,
                  @MatrixParam("pojo")POJO mp, @HeaderParam("pojo")POJO hp);
      }

      @Test
      public void testIt() throws Exception
      {
         MyClient client = ProxyFactory.create(MyClient.class, "http://localhost:8081");
         POJO pojo = new POJO();
         pojo.setName("pojo");
         client.put(pojo, pojo, pojo, pojo);
      }
   }

   </pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="StringParamUnmarshaller"/>25.2. StringParamUnmarshaller</h2></div></div></div><p>org.jboss.resteasy.spi.StringParameterUnmarshaller is sensative to the annotations placed
        on the parameter or field you are injecting into.  It is created per injector.  The setAnnotations()
        method is called by resteasy to initialize the unmarshaller.</p><pre class="programlisting">
package org.jboss.resteasy.spi;

public interface StringParameterUnmarshaller&lt;T&gt;
{
   void setAnnotations(Annotation[] annotations);
   T fromString(String str);
}


</pre><p>You can add this by creating and registering a provider that implements this interface.  You can
        also bind them using a meta-annotation called org.jboss.resteasy.annotationsStringParameterUnmarshallerBinder.
        Here's an example of formatting a java.util.Date based @PathParam</p><pre class="programlisting">
public class StringParamUnmarshallerTest extends BaseResourceTest
{
   @Retention(RetentionPolicy.RUNTIME)
   @StringParameterUnmarshallerBinder(DateFormatter.class)
   public @interface DateFormat
   {
      String value();
   }

   public static class DateFormatter implements StringParameterUnmarshaller&lt;Date&gt;
   {
      private SimpleDateFormat formatter;

      public void setAnnotations(Annotation[] annotations)
      {
         DateFormat format = FindAnnotation.findAnnotation(annotations, DateFormat.class);
         formatter = new SimpleDateFormat(format.value());
      }

      public Date fromString(String str)
      {
         try
         {
            return formatter.parse(str);
         }
         catch (ParseException e)
         {
            throw new RuntimeException(e);
         }
      }
   }

   @Path("/datetest")
   public static class Service
   {
      @GET
      @Produces("text/plain")
      @Path("/{date}")
      public String get(@PathParam("date") @DateFormat("MM-dd-yyyy") Date date)
      {
         System.out.println(date);
         Calendar c = Calendar.getInstance();
         c.setTime(date);
         Assert.assertEquals(3, c.get(Calendar.MONTH));
         Assert.assertEquals(23, c.get(Calendar.DAY_OF_MONTH));
         Assert.assertEquals(1977, c.get(Calendar.YEAR));
         return date.toString();
      }
   }

   @BeforeClass
   public static void setup() throws Exception
   {
      addPerRequestResource(Service.class);
   }

   @Test
   public void testMe() throws Exception
   {
      ClientRequest request = new ClientRequest(generateURL("/datetest/04-23-1977"));
      System.out.println(request.getTarget(String.class));
   }
}

</pre><p>In the example a new annotation is defined called @DateFormat.  This annotation class is
        annotated with the meta-annotation StringParameterUnmarshallerBinder with a reference to the DateFormmater classes.</p><p>The Service.get() method has a @PathParam parameter that is also annotated with @DateFormat.  The application
        of @DateFormat triggers the binding of the DateFormatter.  The DateFormatter will now be run to unmarshal the
        path parameter into the date paramter of the get() method.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Responses_using_javax.ws.rs.core.Response"/>Chapter 26. Responses using javax.ws.rs.core.Response</h2></div></div></div><p>

You can build custom responses using the javax.ws.rs.core.Response and ResponseBuilder classes.  If you want to do your own streaming, your entity response must be an implementation of javax.ws.rs.core.StreamingOutput.   See the java doc for more information.
</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="ExceptionHandling"/>Chapter 27. Exception Handling</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#ExceptionMappers">27.1. Exception Mappers</a></span></dt><dt><span class="sect1"><a href="#builtinException">27.2. Resteasy Built-in Internally-Thrown Exceptions</a></span></dt><dt><span class="sect1"><a href="#overring_resteasy_exceptions">27.3. Overriding Resteasy Builtin Exceptions</a></span></dt></dl></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="ExceptionMappers"/>27.1. Exception Mappers</h2></div></div></div><p>

      ExceptionMappers are custom, application provided, components that can catch thrown application exceptions and
      write specific HTTP responses. The are classes annotated with @Provider and that implement this interface
   </p><p>

      </p><pre class="programlisting">
         package javax.ws.rs.ext;

         import javax.ws.rs.core.Response;

         /**
         * Contract for a provider that maps Java exceptions to
         * {@link javax.ws.rs.core.Response}. An implementation of this interface must
         * be annotated with {@link Provider}.
         *
         * @see Provider
         * @see javax.ws.rs.core.Response
         */
         public interface ExceptionMapper&lt;E&gt;
         {

         /**
         * Map an exception to a {@link javax.ws.rs.core.Response}.
         *
         * @param exception the exception to map to a response
         * @return a response mapped from the supplied exception
         */
         Response toResponse(E exception);
         }
      </pre><p>
   </p><p>

      When an application exception is thrown it will be caught by the JAX-RS runtime. JAX-RS will then scan registered
      ExceptionMappers to see which one support marshalling the exception type thrown. Here is an example of
      ExceptionMapper
   </p><p>

      </p><pre class="programlisting">

         @Provider
         public class EJBExceptionMapper implements ExceptionMapper&lt;javax.ejb.EJBException&gt;
         {

         Response toResponse(EJBException exception) {
         return Response.status(500).build();
         }

         }
      </pre><p>
   </p><p>

      You register ExceptionMappers the same way you do MessageBodyReader/Writers. By scanning, through the resteasy
      provider context-param (if you're deploying via a WAR file), or programmatically through the
      ResteasyProviderFactory class.
   </p><p>


   </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="builtinException"/>27.2. Resteasy Built-in Internally-Thrown Exceptions</h2></div></div></div><p>Resteasy has a set of built-in exceptions that are thrown by it when it encounters errors during dispatching or marshalling.  They all
           revolve around specific HTTP error codes.  You can find them in RESTEasy's javadoc under the package org.jboss.resteasy.spi.  Here's 
           a list of them:</p><div class="table"><a id="d0e2171"/><p class="title"><b>Table 27.1. </b></p><div class="table-contents"><table border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Exception</th><th>HTTP Code</th><th>Description</th></tr></thead><tbody><tr><td>BadRequestException</td><td>400</td><td>Bad Request.  Request wasn't formatted correctly or problem processing request input.</td></tr><tr><td>UnauthorizedException</td><td>401</td><td>Unauthorized.  Security exception thrown if you're using Resteasy's simple annotation-based role-based security</td></tr><tr><td>InternalServerErrorException</td><td>500</td><td>Internal Server Error.</td></tr><tr><td>MethodNotAllowedException</td><td>405</td><td>Method Not Allowed.  There is no JAX-RS method for the resource that can handle the invoked HTTP operation.</td></tr><tr><td>NotAcceptableException</td><td>406</td><td>Not Acceptable.  There is no JAX-RS method that can produce the media types listed in the Accept header.</td></tr><tr><td>NotFoundException</td><td>404</td><td>Not Found.  There is no JAX-RS method that serves the request path/resource.</td></tr><tr><td>ReaderException</td><td>400</td><td>All exceptions thrown from MessageBodyReaders are wrapped within this exception.  If there is no ExceptionMapper for the
wrapped exception or if the excepiton isn't a WebApplicationException, then resteasy will return a 400 code by default.</td></tr><tr><td>WriterException</td><td>500</td><td>All exceptions thrown from MessageBodyWriters are wrapped within this exception.  If there is no ExceptionMapper for the
wrapped exception or if the exception isn't a WebApplicationException, then resteasy will return a 400 code by default.</td></tr><tr><td>o.j.r.plugins.providers.jaxb.JAXBUnmarshalException</td><td>400</td><td>The JAXB providers (XML and Jettison) throw this exception on reads.  They may be wrapping JAXBExceptions.  This class extends ReaderException</td></tr><tr><td>o.j.r.plugins.providers.jaxb.JAXBMarshalException</td><td>500</td><td>The JAXB providers (XML and Jettison) throw this exception on writes.  They may be wrapping JAXBExceptions.  This class extends WriterException</td></tr><tr><td>ApplicationException</td><td>N/A</td><td>This exception wraps all exceptions thrown from application code.  It functions much in the same way as InvocationTargetException.
If there is an ExceptionMapper for wrapped exception, then that is used to handle the request.</td></tr><tr><td>Failure</td><td>N/A</td><td>Internal Resteasy.  Not logged</td></tr><tr><td>LoggableFailure</td><td>N/A</td><td>Internal Resteasy error.  Logged</td></tr><tr><td>DefaultOptionsMethodException</td><td>N/A</td><td>If the user invokes HTTP OPTIONS and no JAX-RS method for it, Resteasy provides a default behavior by throwing this exception</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="overring_resteasy_exceptions"/>27.3. Overriding Resteasy Builtin Exceptions</h2></div></div></div><p>You may override Resteasy built-in exceptions by writing an ExceptionMapper for the exception.  For that matter, you can write an ExceptionMapper
   for any thrown exception including WebApplicationException</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Configuring_Individual_JAX-RS_Resource_Beans"/>Chapter 28. Configuring Individual JAX-RS Resource Beans</h2></div></div></div><p>


</p><p>

If you are scanning your path for JAX-RS annotated resource beans, your beans will be registered in per-request mode.  This means an instance will be created per HTTP request served.  Generally, you will need information from your environment.  If you are running within a servlet container using the WAR-file distribution, in Beta-2 and lower, you can only use the JNDI lookups to obtain references to Java EE resources and configuration information.  In this case, define your EE configuration (i.e. ejb-ref, env-entry, persistence-context-ref, etc...) within web.xml of the resteasy WAR file.  Then within your code do jndi lookups in the java:comp namespace.  For example:
</p><p>

web.xml
</p><pre class="programlisting">

&lt;ejb-ref&gt;
  &lt;ejb-ref-name&gt;ejb/foo&lt;/ejb-ref-name&gt;
  ...
&lt;/ejb-ref&gt;

</pre><p>
</p><p>

resource code:
</p><pre class="programlisting">
@Path("/")
public class MyBean {

   public Object getSomethingFromJndi() {
      new InitialContext.lookup("java:comp/ejb/foo");
   }
...
}
</pre><p>
</p><p>


</p><p>

You can also manually configure and register your beans through the Registry.  To do this in a WAR-based deployment, you need to write a specific ServletContextListener to do this.  Within the listern, you can obtain a reference to the registry as follows:
</p><p>

</p><pre class="programlisting">

public class MyManualConfig implements ServletContextListener
{
   public void contextInitialized(ServletContextEvent event)
   {

      Registry registry = (Registry) event.getServletContext().getAttribute(Registry.class.getName());

   }
...
}

</pre><p>
</p><p>

Please also take a look at our Spring Integration as well as the Embedded Container's Spring Integration
</p><p>

</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="gzip"/>Chapter 29. GZIP Compression/Decompression</h2></div></div></div><p>
    Resteasy has automatic GZIP decompression support.  If the client framework or a JAX-RS
    service receives a messagy body with a Content-Encoding of "gzip", it
    will automatically decompress it.  The client framework automatically
    sets the Accept-Encoding header to be "gzip, deflate".  So you do not
    have to set this header yourself.
    </p><p>Resteasy also supports automatic
    compression.  If the client framework is sending a request
    or the server is sending a response with the Content-Encoding header
    set to "gzip", Resteasy will do the compression. So that you do not
    have to set the Content-Encoding header directly, you can use the
    @org.jboss.resteasy.annotation.GZIP annotation.
   </p><pre class="programlisting">
@Path("/")
public interface MyProxy {

   @Consumes("application/xml")
   @PUT
   public void put(@GZIP Order order);
}
</pre><p>In the above example, we tag the outgoing message body, order, to
   be gzip compressed.  You can use the same annotation to tag server responses
   </p><pre class="programlisting">
@Path("/")
public class MyService {

   @GET
   @Produces("application/xml")
   @GZIP
   public String getData() {...}
}
</pre></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Cache_NoCache_CacheControl"/>Chapter 30. Resteasy Caching Features</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#Cache_Annotation">30.1. @Cache and @NoCache Annotations</a></span></dt><dt><span class="sect1"><a href="#client_cache">30.2. Client "Browser" Cache</a></span></dt><dt><span class="sect1"><a href="#server_cache">30.3. Local Server-Side Response Cache</a></span></dt></dl></div><p>
     Resteasy provides numerous annotations and facilities to support HTTP caching semantics.  Annotations to make setting Cache-Control
     headers easier and both server-side and client-side in-memory caches are available.
   </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Cache_Annotation"/>30.1. @Cache and @NoCache Annotations</h2></div></div></div><p>
      Resteasy provides an extension to JAX-RS that allows you to automatically set Cache-Control headers on a successful
      GET request.  It can only be used on @GET annotated methods.  A successful @GET request is any request
      that returns 200 OK response.
   </p><pre class="programlisting">
package org.jboss.resteasy.annotations.cache;

public @interface Cache
{
   int maxAge() default -1;
   int sMaxAge() default -1;
   boolean noStore() default false;
   boolean noTransform() default false;
   boolean mustRevalidate() default false;
   boolean proxyRevalidate() default false;
   boolean isPrivate() default false;
}

public @interface NoCache
{
   String[] fields() default {};
}

   </pre><p>
      While @Cache builds a complex Cache-Control header, @NoCache is a simplified notation to say that you don't
      want anything cached i.e. Cache-Control: nocache.
   </p><p>
      These annotations can be put on the resource class or interface and specifies a default cache value for each
      @GET resource method.  Or they can be put individually on each @GET resource method.
   </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="client_cache"/>30.2. Client "Browser" Cache</h2></div></div></div><p>
        Resteasy has the ability to set up a client-side, browser-like, cache.  You can use it with the Client Proxy Framework, or with raw
        ClientRequests.  This cache looks for Cache-Control headers sent back with a server response.  If the Cache-Control headers specify
       that the client is allowed to cache the response, Resteasy caches it within local memory.  The cache obeys max-age requirements 
       and will also automatically do HTTP 1.1 cache revalidation if either or both the Last-Modified and/or ETag headers are sent back with the
       original response.  See the HTTP 1.1 specification for details on how Cache-Control or cache revalidation works.
     </p><p>It is very simple to enable caching.  Here's an example of using the client cache with the Client Proxy Framework</p><pre class="programlisting">
@Path("/orders")
public interface OrderServiceClient {

   @Path("{id}")
   @GET
   @Produces("application/xml")
   public Order getOrder(@PathParam("id") String id);
}
</pre><p>To create a proxy for this interface and enable caching for that proxy requires only a few simple steps:</p><pre class="programlisting">
import org.jboss.resteasy.client.ProxyFactory;
import org.jboss.resteasy.client.cache.CacheFactory;
import org.jboss.resteasy.client.cache.LightweightBrowserCache;

public static void main(String[] args) throws Exception
{
      RegisterBuiltin.register(ResteasyProviderFactory.getInstance());
      OrderServiceClient proxy = ProxyFactory.create(OrderServiceClient.class, generateBaseUrl());

      // This line enables caching
      LightweightBrowserCache cache = CacheFactory.makeCacheable(proxy);
}
</pre><p>If you are using the ClientRequest class to make invocations rather than the proxy framework, it is just as easy</p><pre class="programlisting">
import org.jboss.resteasy.client.ProxyFactory;
import org.jboss.resteasy.client.cache.CacheFactory;
import org.jboss.resteasy.client.cache.LightweightBrowserCache;

public static void main(String[] args) throws Exception
{
      RegisterBuiltin.register(ResteasyProviderFactory.getInstance());

      // This line enables caching
      LightweightBrowserCache cache = new LightweightBrowserCache();

      ClientRequest request = new ClientRequest("http://example.com/orders/333");
      CacheFactory.makeCacheable(request, cache);
}
</pre><p>The LightweightBrowserCache, by default, has a maximum 2 megabytes of caching space.  You can change this programmatically by callings
         its setMaxBytes() method.   If the cache gets full, the cache completely wipes itself of all cached data.  This may seem
         a bit draconian, but the cache was written to avoid unnecessary synchronizations in a concurrent environment where the cache is 
         shared between multiple threads.  If you desire a more complex caching solution or if you want to plug in a thirdparty cache
         please contact our resteasy-developers list and discuss it with the community.
   </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="server_cache"/>30.3. Local Server-Side Response Cache</h2></div></div></div><p>Resteasy has a server-side, local, in-memory cache that can sit in front of your JAX-RS services.  It automatically caches marshalled responses from HTTP GET JAX-RS invocations if, and only if your JAX-RS resource method sets a Cache-Control header.  When a GET comes in, the Resteasy Server Cache checks to see if the URI is stored in the cache.  If it does, it returns the already marshalled response without invoking your JAX-RS method.  Each cache entry has a max age to whatever is specified in the Cache-Control header of the initial request.  The cache also will automatically generate an ETag using an MD5 hash on the response body.  This allows the client to do HTTP 1.1 cache revalidation with the IF-NONE-MATCH header.  The cache is also smart enough to perform revalidation if there is no initial cache hit, but the jax-rs method still returns a body that has the same ETag.
      </p><p>To set up the server-side cache, there are a few simple steps you have to perform.  If you are using Maven you must depend on the resteasy-cache-core artifact:</p><pre class="programlisting">

&lt;dependency&gt;
   &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
   &lt;artifactId&gt;resteasy-cache-core&lt;/artifactId&gt;
   &lt;version&gt;1.2.1.GA&lt;/version&gt;
&lt;/dependency&gt;

</pre><p>The next thing you have to do is to add a ServletContextListener, org.jboss.resteasy.plugins.cache.server.ServletServerCache.  
            This must be specified after the ResteasyBootstrap listener in your web.xml file.</p><pre class="programlisting">

&lt;web-app&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;
            org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap
        &lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.server.cache.maxsize&lt;/param-name&gt;
        &lt;param-value&gt;1000&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.server.cache.eviction.wakeup.interval&lt;/param-name&gt;
        &lt;param-value&gt;5000&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;
            org.jboss.resteasy.plugins.cache.server.ServletServerCache
        &lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/rest-services/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

</pre><p>The cache implementation is based on the JBoss Cache project: http://jboss.org/jbosscache.  There are two context-param configuration variables
         that you can set.  resteasy.server.cache.maxsize sets the number of elements that can be cached.  The resteasy.server.cache.eviction.wakeup.interval sets the rate at which the background eviction thread runs to purge the cache of stale entries.
   </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Interceptors"/>Chapter 31. Interceptors</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#MessageBodyInterceptors">31.1. MessageBodyReader/Writer Interceptors</a></span></dt><dt><span class="sect1"><a href="#PreProcessInterceptors">31.2. PreProcessInterceptor</a></span></dt><dt><span class="sect1"><a href="#PostProcessInterceptors">31.3. PostProcessInterceptors</a></span></dt><dt><span class="sect1"><a href="#ClientExecutionInterceptors">31.4. ClientExecutionInterceptors</a></span></dt><dt><span class="sect1"><a href="#BindingInterceptors">31.5. Binding Interceptors</a></span></dt><dt><span class="sect1"><a href="#registering">31.6. Registering Interceptors</a></span></dt><dt><span class="sect1"><a href="#interceptorPrecedence">31.7. Interceptor Ordering and Precedence</a></span></dt><dd><dl><dt><span class="sect2"><a href="#customprecedence">31.7.1. Custom Precedence</a></span></dt></dl></dd></dl></div><p>Resteasy has the capability to intercept JAX-RS invocations and route them through listener-like objects
    called interceptors.  There are 4 different interception points on the serverside: wrapping around
    MessageBodyWriter invocations, wrapping around MessageBodyReader invocations, pre-processors the intercept
    the incoming request before anything is unmarshalled, and post processors which are invoked right
    after the JAX-RS method is finished.  On the client side you can also intercept MessageBodyReader and Writer
    as well as the remote invocation to the server.</p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="MessageBodyInterceptors"/>31.1. MessageBodyReader/Writer Interceptors</h2></div></div></div><p>MessageBodyReader and Writer interceptors work off of the same principles.  They wrap around the
        invocation of MessageBodyReader.readFrom() or MessageBodyWriter.writeTo().  You can use them to
        wrap the Output or InputStream.  For example, the Resteasy GZIP support has interceptors that create
        and override the default Output and InputStream with a GzipOutpuStream or GzipInputStream so that
        gzip encoding can work.  You could use them to append headers to the response (or on the client side,
            the outgoing request).</p><p>To implement one you implement the org.jbos.resteasy.spi.interception.MessageBodyReaderInterceptor or
        MessageBodyWriterInterceptor</p><pre class="programlisting">

public interface MessageBodyReaderInterceptor
{
   Object read(MessageBodyReaderContext context) throws IOException, WebApplicationException;

}

public interface MessageBodyWriterInterceptor
{
   void write(MessageBodyWriterContext context) throws IOException, WebApplicationException;

}

            
</pre><p>
            Interceptors are driven by the MessageBodyWriterContext or MessageBodyReaderContext.  The interceptors
            and the MessageBodyReader or Writer is invoked in one big Java call stack.  You must call
            MessageBodyReaderContext.proceed() or MessageBodyWriterContext.proceed() to go to the next interceptor
            or, if there are no more interceptors to invoke, the readFrom() or writeTo() method of the MessageBodyReader
            or MessageBodyWriter.  This wrapping allows you to modify things before they get to the Reader or Writer
            then clean up after proceed() returns.  The Context objects also have methods to modify the parameters
            going to the Reader or Writer.
        </p><pre class="programlisting">

public interface MessageBodyReaderContext
{
   Class getType();

   void setType(Class type);

   Type getGenericType();

   void setGenericType(Type genericType);

   Annotation[] getAnnotations();

   void setAnnotations(Annotation[] annotations);

   MediaType getMediaType();

   void setMediaType(MediaType mediaType);

   MultivaluedMap&lt;String, String&gt; getHeaders();

   InputStream getInputStream();

   void setInputStream(InputStream is);

   Object proceed() throws IOException, WebApplicationException;
}

public interface MessageBodyWriterContext
{
   Object getEntity();

   void setEntity(Object entity);

   Class getType();

   void setType(Class type);

   Type getGenericType();

   void setGenericType(Type genericType);

   Annotation[] getAnnotations();

   void setAnnotations(Annotation[] annotations);

   MediaType getMediaType();

   void setMediaType(MediaType mediaType);

   MultivaluedMap&lt;String, Object&gt; getHeaders();

   OutputStream getOutputStream();

   public void setOutputStream(OutputStream os);

   void proceed() throws IOException, WebApplicationException;
}

</pre><p>
            MessageBodyReaderInterceptors and MessageBodyWriterInterceptors can be used on the serverside or client side.
            They must be annotated with @org.jboss.resteasy.annotations.interception.ServerInterceptor or
            @org.jboss.resteasy.annotations.interception.ClientInterceptor so that resteasy knows whether or not
            to add them to the interceptor list.  If you do not annotate your interceptor classes with one or both
            of these annotations, you will receive a deployment error.  They also
            should be annotated with @Provider.  Lets look at an example:
        </p><pre class="programlisting">
@Provider
@ServerInterceptor
public class MyHeaderDecorator implements MessageBodyWriterInterceptor {

    public void write(MessageBodyWriterContext context) throws IOException, WebApplicationException
    {
       context.getHeaders().add("My-Header", "custom");
       context.proceed();
    }
}
</pre><p>Here we have a server side interceptor that adds a header value to the
            response.  You see that it is annotated with @Provider and @ServerInterceptor.
        It must modify the header before calling context.proceed() as the reseponse may
        be committed after the MessageBodyReader runs.  Remember, you MUST call context.proceed().  If
        you don't, your invocation will not happen.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="PreProcessInterceptors"/>31.2. PreProcessInterceptor</h2></div></div></div><p>The org.jboss.resteasy.spi.interception.PreProcessInterceptor runs after a JAX-RS resource
        method is found to invoke on, but before the actual invocation happens.  They are only usable on the
            server, but still must be annotated with @ServerInterceptor.  They can be used to implement security features or
        can preempt the Java request.  The Resteasy security implementation uses this type of interceptor to abort
        requests before the actually happen if the user does not pass authorization.  The Resteasy caching
        framework also uses this to return cached responses to avoid invoking methods again.   Here's what
        the interceptor interface looks like:</p><pre class="programlisting">
    public interface PreProcessInterceptor
    {
       ServerResponse preProcess(HttpRequest request, ResourceMethod method) throws Failure, WebApplicationException;
    }

</pre><p>PreProcessInterceptors run in sequence and
        do not wrap the actual JAX-RS invocation.  Here's some pseudo code that illustrates how they work:</p><pre class="programlisting">
    for (PreProcessInterceptor interceptor : preProcessInterceptors) {
       ServerResponse response = interceptor.preProcess(request, method);
       if (response != null) return response;
    }
    executeJaxrsMethod(...);
</pre><p>If the preProcess() method returns a ServerResponse then the underlying JAX-RS method will not get
        invoked and the runtime will process the response and return to the client.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="PostProcessInterceptors"/>31.3. PostProcessInterceptors</h2></div></div></div><p>
          The org.jboss.resteasy.spi.interception.PostProcessInterceptor runs after the JAX-RS method was invoked
            but before MessageBodyWriters are invoked.  They can only be used on the server side.  Use them
            if you need to set a response header when there might not
            be any MessageBodyWriter invoked.  They are there for symetry with PreProcessInterceptor.  They do not wrap anything and
            are invoked in order like PreProcessInterceptors are.
        </p><pre class="programlisting">
    public interface PostProcessInterceptor
    {
       void postProcess(ServerResponse response);
    }
    
</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="ClientExecutionInterceptors"/>31.4. ClientExecutionInterceptors</h2></div></div></div><p>org.jboss.resteasy.spi.interception.ClientExecutionInterceptor classes only are usable on the client
        side.  They run after the MessageBodyWriter and after the ClientRequest has been totally built on the client side.
        They wrap around the actually HTTP invocation that goes to the server.  Resteasy GZIP support uses them
        to set the Accept header to contain "gzip, deflate" before the request goes out.  The Resteasy client cache
        uses it to check to see if its cache contains the resource before going over the wire.  These interceptors
        must be annotated with @ClientInterceptor and @Provider.</p><pre class="programlisting">
    public interface ClientExecutionInterceptor
    {
       ClientResponse execute(ClientExecutionContext ctx) throws Exception;
    }

    public interface ClientExecutionContext
    {
       ClientRequest getRequest();

       ClientResponse proceed() throws Exception;
    }
    
</pre><p>The work work in the same pattern as MessageBodyReader/WriterInterceptors in that you must call
        proceed() unless you want to abort the invocation.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="BindingInterceptors"/>31.5. Binding Interceptors</h2></div></div></div><p>By default, any registered interceptor will be invoked for any request you do.  By default, every
        request will use your interceptors.  You can fine tune this by having your interceptors implement the
        org.jboss.resteasy.spi.AcceptedByMethod interface:</p><pre class="programlisting">
    public interface AcceptedByMethod
    {
       public boolean accept(Class declaring, Method method);
    }

</pre><p>If your interceptor implements this interface, Resteasy will invoke the accept() method.  If this
        method returns true, Resteasy will add that interceptor to the JAX-RS method's call chain.  If it returns
        false then it won't be added to the call chain.  For example:</p><pre class="programlisting">
@Provider
@ServerInterceptor
public class MyHeaderDecorator implements MessageBodyWriterInterceptor, AcceptedByMethod {

    public boolean accept(Class declaring, Method method) {
       return method.isAnnotationPresent(GET.class);
    }

   public void write(MessageBodyWriterContext context) throws IOException, WebApplicationException
   {
      context.getHeaders().add("My-Header", "custom");
      context.proceed();
   }
}
        </pre><p>In this example, our accept() method checks to see if the @GET annotation is present on our
        JAX-RS method.  If it is, then this interceptor will be applied to that method's call chain.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="registering"/>31.6. Registering Interceptors</h2></div></div></div><p>Registering interceptors is easy.  Since they are a @Provider, (you remebered to annotate it right?)
        they can be listed in the resteasy.providers context-param in web.xml or returned as a class or object in the
        Application.getClasses() or Appication.getSingletons() method.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="interceptorPrecedence"/>31.7. Interceptor Ordering and Precedence</h2></div></div></div><p>Some interceptors are very sensitive in which order they are invoked.  For example, you always want your
        security interceptor invoked first.  Other interceptor's behavior might be triggered by a different interceptor
        that adds a header.  By default, you have no control over the order in which registered interceptors are invoked.
        There is a way to specify interceptor precedence though.</p><p>You do not specify interceptor precedence by listing interceptor classes.  Instead, there are precedence
        families and a particular interceptor class is associated with a family via the @org.jboss.resteasy.annotations.interception.Precedence annotation.
        We did this because some of the built in interceptors included with Resteasy are very sensitive to ordering.  By specifying
        precedence through a family structure, we can protect these built in interceptors.  An advantage to this approach
        is that configuration is also a lot easier too for you.</p><p>These are the families and the order in which they are executed:</p><pre class="programlisting">
    SECURITY
    HEADER_DECORATOR
    ENCODER
    REDIRECT
    DECODER
</pre><p>Any interceptor not associated with a precedence family will be invoked last.  SECURITY usually involves
        PreProcessInterceptors.  They should be invoked first because you want to do as little as possible before
        your invocation is authorized.  HEADER_DECORATORs are interceptors that add headers to a response or
        an outgoing request.  They need to come next because these added headers may effect the behavior of other
        interceptors.  ENCODER interceptors change the OutputStream.  For example, the GZIP interceptor
            creates a GZIPOutputStream to wrap the real OutputStream for compression.
            REDIRECT interceptors usually are used in PreProcessInterceptors as they may reroute the request
        and totally bypas the JAX-RS method.  DECODER interceptors wrap the InputStream.  For example, the
        GZIP interceptor decoder wraps the InputStream in a GzipInputStream instance.</p><p>To marry your custom interceptors to a particular family you annotate it with the
            @org.jboss.resteasy.annotations.interception.Precendence annotation.</p><pre class="programlisting">
@Provider
@ServerInterceptor
@ClientInterceptor
@Precedence("ENCODER")
public class MyCompressionInterceptor implements MessageBodyWriterInterceptor {...}
</pre><p>For complete type safety, there are convenience annotations in the org.jbos.resteasy.annotations.interception
        package:  @DecoredPrecedence, @EncoderPrecedence, @HeaderDecoratorPrecedence, @RedirectPrecedence,
        @SecurityPrecedence.  Use these instead of the @Precedence annotation</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="customprecedence"/>31.7.1. Custom Precedence</h3></div></div></div><p>You can define your own precedence families.  Apply them using the @Precedence annotation.</p><pre class="programlisting">
 @Provider
 @ServerInterceptor
 @Precedence("MY_CUSTOM_PRECEDENCE")
 public class MyCustomInterceptor implements MessageBodyWriterInterceptor {...}
            </pre><p>You can create your own convenience annotation by using @Precedence as a meta-annotation</p><pre class="programlisting">
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Precedence("MY_CUSTOM_PRECEDENCE")
public @interface MyCustomPrecedence {}
</pre><p>You must register your custom precedence.  Otherwise, Resteasy will give you an error at deployment
            time.  You do this with the context params:</p><pre class="programlisting">
resteasy.append.interceptor.precedence
resteasy.interceptor.before.precedence
resteasy.interceptor.after.precedence</pre><p>resteasy.append.interceptor.precedence simply appends the precedence family to the list.
            resteasy.interceptor.before.precedence allows you to specify a family your new precedence comes before.
            resteasy.interceptor.after.precedence allows you to specify a family your new precedence comes after.
            For example:</p><pre class="programlisting">

web-app&gt;
    &lt;display-name&gt;Archetype RestEasy Web Application&lt;/display-name&gt;

    &lt;!-- testing configuration --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.append.interceptor.precedence&lt;/param-name&gt;
        &lt;param-value&gt;END&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.interceptor.before.precedence&lt;/param-name&gt;
        &lt;param-value&gt;ENCODER : BEFORE_ENCODER&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.interceptor.after.precedence&lt;/param-name&gt;
        &lt;param-value&gt;ENCODER : AFTER_ENCODER&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.servlet.mapping.prefix&lt;/param-name&gt;
        &lt;param-value&gt;/test&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/test/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
        

</pre><p>In this web.xml file, we've define 3 new precedence families: END, BEFORE_ENCODER, and AFTER_ENCODER.  Here's
            what the family order would look like with this configuration:</p><pre class="programlisting">
SECURITY
HEADER_DECORATOR
BEFORE_ENCODER
ENCODER
AFTER_ENCODER
REDIRECT
DECODER
END
            </pre></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Asynchronous_HTTP_Request_Processing"/>Chapter 32. Asynchronous HTTP Request Processing</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#Asynch_HTTP_Tomcat6">32.1. Tomcat 6 and JBoss 4.2.3 Support</a></span></dt><dt><span class="sect1"><a href="#Asynch_HTTP_Servlet3">32.2. Servlet 3.0 Support</a></span></dt><dt><span class="sect1"><a href="#Asynch_HTTP_JBossWeb">32.3. JBossWeb, JBoss AS 5.0.x Support</a></span></dt></dl></div><p>
      Asynchronous HTTP Request Processing is a relatively new technique that allows you to process a single HTTP
      request using non-blocking I/O and, if desired in separate threads. Some refer to it as COMET capabilities.
      The primary usecase for Asynchronous HTTP is
      in the case where the client is polling the server for a delayed response. The usual example is an AJAX chat
      client where you want to push/pull from both the client and the server. These scenarios have the client blocking
      a long time on the server’s socket waiting for a new message. What happens in synchronous HTTP where the server is
      blocking on incoming and outgoing I/O is that you end up having a thread consumed per client connection.
      This eats up memory and valuable thread resources. Not such a big deal in 90% of applications (in fact using
      asynchronous processing make actually hurt your performance in most common scenaiors), but when you start
      getting a lot of concurrent clients that are blocking like this, there’s a lot of wasted resources and your
      server does not scale that well.
   </p><p>
      Tomcat, Jetty, and JBoss Web all have similar, but proprietary support for asynchronout HTTP request processing.
      This functionality is currently being standardized in the Servlet 3.0 specification. Resteasy provides a very
      simple callback API to provide asynchronous capabilities. Resteasy currently supports integration with Servlet 3.0
      (through Jetty 7), Tomcat 6, and JBoss Web 2.1.1.
   </p><p>
      The Resteasy asychronous HTTP support is implemented via two classes. The @Suspend annotation and the
      AsynchronousResponse interface.
   </p><pre class="programlisting">
public @interface Suspend
{
   long value() default -1;
}

import javax.ws.rs.core.Response;

public interface AsynchronousResponse
{
   void setResponse(Response response);
}
   </pre><p>
      The @Suspend annotation tells Resteasy that the HTTP request/response should be detached from the currently
      executing thread and that the current thread should not try to automaticaly process the response. The
      argument to @Suspend is a timeout in milliseconds until the request will be cancelled.
   </p><p>
      The AsynchronousResponse is the callback object. It is injected into the method by Resteasy.
      Application code hands off the AsynchronousResponse to a different thread for processing.
      The act of calling setResponse() will cause a response to be sent back to the client and will also terminate the
      HTTP request. Here is an example of asynchronous processing:
   </p><pre class="programlisting">
import org.jboss.resteasy.annotations.Suspend;
import org.jboss.resteasy.spi.AsynchronousResponse;

@Path("/")
public class SimpleResource
{

   @GET
   @Path("basic")
   @Produces("text/plain")
   public void getBasic(final @Suspend(10000) AsynchronousResponse response) throws Exception
   {
      Thread t = new Thread()
      {
         @Override
         public void run()
         {
            try
            {
               Response jaxrs = Response.ok("basic").type(MediaType.TEXT_PLAIN).build();
               response.setResponse(jaxrs);
            }
            catch (Exception e)
            {
               e.printStackTrace();
            }
         }
      };
      t.start();
   }
}
   </pre><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Asynch_HTTP_Tomcat6"/>32.1. Tomcat 6 and JBoss 4.2.3 Support</h2></div></div></div><p>
         To use Resteasy's Asynchronous HTTP apis with Tomcat 6 or JBoss 4.2.3, you must use a special Restasy Servlet
         and
         configure Tomcat (or JBoss Web in JBoss 4.2.3) to use the NIO transport. First edit Tomcat's (or JBoss Web's)
         server.xml file. Comment out the vanilla HTTP adapter and add this:
      </p><pre class="programlisting">
&lt;Connector port="8080" address="${jboss.bind.address}"
   emptySessionPath="true" protocol="org.apache.coyote.http11.Http11NioProtocol"
   enableLookups="false" redirectPort="6443" acceptorThreadCount="2" pollerThreadCount="10"
/&gt;
      </pre><p>
         Your deployed Resteasy applications must also use a different Resteasy servlet,
         org.jboss.resteasy.plugins.server.servlet.Tomcat6CometDispatcherServlet. This class is available
         within the async-http-tomcat-xxx.jar or within the Maven repository under the
         async-http-tomcat6 artifact id. web.xml
      </p><pre class="programlisting">
&lt;servlet&gt;
   &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
   &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.Tomcat6CometDispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
      </pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Asynch_HTTP_Servlet3"/>32.2. Servlet 3.0 Support</h2></div></div></div><p>
         Our Servlet 3.0 support has only been tested with JBoss AS 6 M4 (trunk SVN as of 7/12/2010).
      </p><p>
         Your deployed Resteasy applications must also use a different Resteasy servlet,
         org.jboss.resteasy.plugins.server.servlet.HttpServlet30Dispatcher. This class is available
         within the async-http-servlet-3.0-xxx.jar or within the Maven repository under the
         async-http-servlet-3.0 artifact id. web.xml:
      </p><pre class="programlisting">

   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServlet30Dispatcher&lt;/servlet-class&gt;
      &lt;async-supported&gt;true&lt;/async-supported&gt;
   &lt;/servlet&gt;
      </pre><p>
           There's also a Filter30Dispatcher class if you want to use Resteasy as a filter.  If you are running within
           JBoss AS 6 M4 or higher, you do not have to add this config to your web.xml if you are relying on the app
           server to do automatic scanning and have web.xml empty.
       </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Asynch_HTTP_JBossWeb"/>32.3. JBossWeb, JBoss AS 5.0.x Support</h2></div></div></div><p>
         The JBossWeb container shipped with JBoss AS 5.0.x and higher requires you to install the JBoss Native plugin
         to enable asynchronous HTTP processing. Please see the JBoss Web documentation on how to do this.
      </p><p>
         Your deployed Resteasy applications must also use a different Resteasy servlet,
         org.jboss.resteasy.plugins.server.servlet.JBossWebDispatcherServlet. This class is available
         within the async-http-jbossweb-xxx.jar or within the Maven repository under the
         async-http-jbossweb artifact id. web.xml:
      </p><pre class="programlisting">
&lt;servlet&gt;
   &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
   &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.JBossWebDispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
      </pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="async_job_service"/>Chapter 33. Asynchronous Job Service</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#async_job">33.1. Using Async Jobs</a></span></dt><dt><span class="sect1"><a href="#oneway">33.2. Oneway: Fire and Forget</a></span></dt><dt><span class="sect1"><a href="#async_job_setup">33.3. Setup and Configuration</a></span></dt></dl></div><p>
      The Resteasy Asynchronous Job Service is an implementation of the Asynchronous Job pattern defined in O'Reilly's "Restful Web Services" book.  The idea of it is to bring asynchronicity to a synchronous protocol.
   </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="async_job"/>33.1. Using Async Jobs</h2></div></div></div><p>While HTTP is a synchronous protocol
      it does have a faint idea of asynchronous invocations.  The HTTP 1.1 response code 202, "Accepted" means that the server
      has received and accepted the response for processing, but the processing has not yet been completed.  The Resteasy 
      Asynchronous Job Service builds around this idea.
   </p><pre class="programlisting">
POST http://example.com/myservice?asynch=true
</pre><p>
    For example, if you make the above post with the asynch query parameter set to true, Resteasy will return a 202, "Accepted" response code and run the invocation in the background.  It also sends back a Location header with a URL pointing to where the response of the background method is located.
   </p><pre class="programlisting">
HTTP/1.1 202 Accepted
Location: http://example.com/asynch/jobs/3332334
</pre><p>
   The URI will have the form of:
   </p><pre class="programlisting">
/asynch/jobs/{job-id}?wait={millisconds}|nowait=true
</pre><p>You can perform the GET, POST, and DELETE operations on this job URL.  GET returns whatever the JAX-RS resource method you invoked
   returned as a response if the job was completed.  If the job has not completed, this GET will return a response code of 202, Accepted.  Invoking GET does not remove the job, so you can call it multiple times.  When Resteasy's job queue gets full, it will evict
the least recently used job from memory.  You can manually clean up after yourself by calling DELETE on the URI.  POST does
a read of the JOB response and will remove the JOB it has been completed.
</p><p>Both GET and POST allow you to specify a maximum
wait time in milliseconds, a "wait" query parameter.  Here's an example:
</p><pre class="programlisting">
POST http://example.com/asynch/jobs/122?wait=3000
</pre><p>  If you do not specify a "wait" parameter, the GET or POST will not wait at all if the job is not complete.</p><p>  NOTE!!  While you can invoke GET, DELETE, and PUT methods asynchronously, this breaks the HTTP 1.1 contract of these methods.  While these invocations may not change the state of the resource if invoked more than once, they do change the state of the server as new Job entries with each invocation.  If you want to be a purist, stick with only invoking POST methods asynchronously.
   </p><p> Security NOTE!  Resteasy role-based security (annotations) does not work with the Asynchronoous Job Service.  You must use
   XML declaritive security within your web.xml file. Why? It is impossible to implement role-based security portably.  In the future, we may have specific JBoss integration, but will not support other environments.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="oneway"/>33.2. Oneway: Fire and Forget</h2></div></div></div><p>
         Resteasy also supports the notion of fire and forget.  This will also return a 202, Accepted response, but no Job will
         be created.  This is as simple as using the oneway query parameter instead of asynch.  For example:
      </p><pre class="programlisting">
POST http://example.com/myservice?oneway=true
</pre><p> Security NOTE!  Resteasy role-based security (annotations) does not work with the Asynchronoous Job Service.  You must use
   XML declaritive security within your web.xml file. Why? It is impossible to implement role-based security portably.  In the future, we may have specific JBoss integration, but will not support other environments.</p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="async_job_setup"/>33.3. Setup and Configuration</h2></div></div></div><p>You must enable the Asychronous Job Service in your web.xml file as it is not turned on by default.</p><pre class="programlisting">

&lt;web-app&gt;
    &lt;!-- enable the Asynchronous Job Service --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.enabled&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- The next context parameters are all optional.  
         Their default values are shown as example param-values --&gt;

    &lt;!-- How many jobs results can be held in memory at once? --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.max.job.results&lt;/param-name&gt;
        &lt;param-value&gt;100&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Maximum wait time on a job when a client is querying for it --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.max.wait&lt;/param-name&gt;
        &lt;param-value&gt;300000&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Thread pool size of background threads that run the job --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.thread.pool.size&lt;/param-name&gt;
        &lt;param-value&gt;100&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Set the base path for the Job uris --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.async.job.service.base.path&lt;/param-name&gt;
        &lt;param-value&gt;/asynch/jobs&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;
            org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap
        &lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

</pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="RESTEasy_Embedded_Container"/>Chapter 34. Embedded Container</h2></div></div></div><p>

RESTeasy JAX-RS comes with an embeddable server that you can run within your classpath.  It packages TJWS embeddable servlet container with JAX-RS.
</p><p>

From the distribution, move the jars in resteasy-jaxrs.war/WEB-INF/lib into your classpath.  You must both programmatically register your JAX-RS beans using the embedded server's Registry.  Here's an example:
</p><p>

</p><pre class="programlisting">

@Path("/")
public class MyResource {

   @GET
   public String get() { return "hello world"; }
 

   public static void main(String[] args) throws Exception 
   {
      TJWSEmbeddedJaxrsServer tjws = new TJWSEmbeddedJaxrsServer();
      tjws.setPort(8081);
      tjws.getDeployment().getActualResourceClasses().add(MyResource.class);
      tjws.start();
   }
}

</pre><p>
</p><p>

The server can either host non-encrypted or SSL based resources, but not both.  See the Javadoc for TJWSEmbeddedJaxrsServer as well as its superclass TJWSServletServer.  The TJWS website is also a good place for information.
</p><p>


</p><p>

If you want to use Spring, see the SpringBeanProcessor.  Here's a pseudo-code example
</p><p>

</p><pre class="programlisting">

   public static void main(String[] args) throws Exception 
   {
      final TJWSEmbeddedJaxrsServer tjws = new TJWSEmbeddedJaxrsServer();
      tjws.setPort(8081);

      tjws.start();
      org.jboss.resteasy.plugins.server.servlet.SpringBeanProcessor processor = new SpringBeanProcessor(tjws.getDeployment().getRegistry(), tjws.getDeployment().getFactory();
      ConfigurableBeanFactory factory = new XmlBeanFactory(...);
      factory.addBeanPostProcessor(processor);
   }
</pre><p>
      </p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="RESTEasy_Server-side_Mock_Framework"/>Chapter 35. Server-side Mock Framework</h2></div></div></div><p>

Although RESTEasy has an Embeddable Container, you may not be comfortable with the idea of starting and stopping a web server within unit tests (in reality, the embedded container starts in milli seconds), or you might not like the idea of using Apache HTTP Client or java.net.URL to test your code.  RESTEasy provides a mock framework so that you can invoke on your resource directly.
</p><p>

</p><pre class="programlisting">
import org.jboss.resteasy.mock.*;
...

      Dispatcher dispatcher = MockDispatcherFactory.createDispatcher();

      POJOResourceFactory noDefaults = new POJOResourceFactory(LocatingResource.class);
      dispatcher.getRegistry().addResourceFactory(noDefaults);

      {
         MockHttpRequest request = MockHttpRequest.get("/locating/basic");
         MockHttpResponse response = new MockHttpResponse();

         dispatcher.invoke(request, response);


         Assert.assertEquals(HttpServletResponse.SC_OK, response.getStatus());
         Assert.assertEquals("basic", response.getContentAsString());
      }
</pre><p>
</p><p>

See the RESTEasy Javadoc for all the ease-of-use methods associated with MockHttpRequest, and MockHttpResponse.
</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Securing_JAX-RS_and_RESTeasy"/>Chapter 36. Securing JAX-RS and RESTeasy</h2></div></div></div><p>

Because Resteasy is deployed as a servlet, you must use standard web.xml constraints to enable authentication and authorization.  
</p><p>

Unfortunately, web.xml constraints do not mesh very well with JAX-RS in some situations.  The problem is that web.xml URL pattern matching is very very limited.  URL patterns in web.xml only support simple wildcards, so JAX-RS resources like:
</p><p>

</p><pre class="programlisting">/{pathparam1}/foo/bar/{pathparam2} </pre><p>
</p><p>

Cannot be mapped as a web.xml URL pattern like:
</p><p>

</p><pre class="programlisting">/*/foo/bar/*</pre><p>
</p><p>

To get around this problem you will need to use the security annotations defined below on your JAX-RS methods.  You will still need to set up some general security constraint elements in web.xml to turn on authentication.
</p><p>


</p><p>

Resteasy JAX-RS supports the @RolesAllowed, @PermitAll and @DenyAll annotations on JAX-RS methods.   By default though, Resteasy does not recognize these annotations.  You have to 
configure Resteasy to turn on role-based security by setting a context parameter.  NOTE!!!  Do not turn on this switch if you are using EJBs.  The EJB container will provide this
functionality instead of Resteasy.

</p><pre class="programlisting">

&lt;web-app&gt;
...
   &lt;context-param&gt;
      &lt;param-name&gt;resteasy.role.based.security&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
   &lt;/context-param&gt;
&lt;/web-app&gt;
</pre><p>There is a bit of quirkiness with this approach.   You will have to declare all roles used within the Resteasy JAX-RS war file that you are using in your JAX-RS classes and set up a security constraint that permits all of these roles access to every URL handled by the JAX-RS runtime.  You'll just have to trust that Resteasy JAX-RS authorizes properly.
</p><p>

How does Resteasy do authorization?  Well, its really simple.  It just sees if a method is annotated with @RolesAllowed and then just does HttpServletRequest.isUserInRole.  If one of the the @RolesAllowed passes, then allow the request, otherwise, a response is sent back with a 401 (Unauthorized) response code.
</p><p>

So, here's an example of a modified RESTEasy WAR file.  You'll notice that every role declared is allowed access to every URL controlled by the Resteasy servlet.
</p><p>

</p><pre class="programlisting">

&lt;web-app&gt;

   &lt;context-param&gt;
      &lt;param-name&gt;resteasy.role.based.security&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
   &lt;/context-param&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;

   &lt;security-constraint&gt;
      &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Resteasy&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/security&lt;/url-pattern&gt;
      &lt;/web-resource-collection&gt;
       &lt;auth-constraint&gt;
         &lt;role-name&gt;admin&lt;/role-name&gt;
         &lt;role-name&gt;user&lt;/role-name&gt;
      &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;

   &lt;login-config&gt;
      &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
      &lt;realm-name&gt;Test&lt;/realm-name&gt;
   &lt;/login-config&gt;

   &lt;security-role&gt;
      &lt;role-name&gt;admin&lt;/role-name&gt;
   &lt;/security-role&gt;
   &lt;security-role&gt;
      &lt;role-name&gt;user&lt;/role-name&gt;
   &lt;/security-role&gt;


&lt;/web-app&gt;


</pre><p>
</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Authentication"/>Chapter 37. Authentication</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2674">37.1. OAuth core 1.0a</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2694">37.1.1. Authenticating with OAuth</a></span></dt><dt><span class="section"><a href="#d0e2772">37.1.2. Accessing protected resources</a></span></dt><dt><span class="section"><a href="#d0e2815">37.1.3. Implementing an OAuthProvider</a></span></dt></dl></dd></dl></div><p>Since Resteasy runs within a servlet container you can use most (all?) mechanism available in your servlet container for authentication.  Basic and Digest
    authentication are probably the easiest to set up and fit nicely into REST's stateless principle.  Form security can be used, but requires passing
    the session's cookie value with each request.  We have done some preliminary work on OAuth and also plan to work on OpenID and SAML integration in the future.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2674"/>37.1. OAuth core 1.0a</h2></div></div></div><p>
    		RESTEasy has preliminary support for <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://oauth.net/core/1.0a">OAuth core 1.0a</a>.
    		This includes support for authenticating with OAuth (as described by the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://oauth.net/core/1.0a#rfc.section.6">spec section 6</a>)
    		and OAuth authentication for protected resources (as described by the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://oauth.net/core/1.0a#rfc.section.7">spec section 7</a>).
    	</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
    			This API should be considered experimental and not suitable for production yet, especially for tight security.
    			It is not final yet and subject to change. If you have comments, bugs, feature requests or questions, contact us
    			through the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://lists.sourceforge.net/lists/listinfo/RESTEasy-developers">RESTEasy mailing list</a>.
    		</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2694"/>37.1.1. Authenticating with OAuth</h3></div></div></div><p>
				OAuth authentication is the process in which Users grant access to their Protected Resources without sharing their credentials with the Consumer.
			</p><p>
				OAuth Authentication is done in three steps:
			</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
						The Consumer obtains an unauthorized Request Token. This part is handled by RESTEasy.
					</p></li><li><p>
					The User authorizes the Request Token. This part is <span class="emphasis"><em>not handled by RESTEasy</em></span> because it requires a user interface where the User
					logs in and authorizes or denies the Request Token. This cannot be implemented automatically as it needs to be integrated with your User login process
					and user interface.
					</p></li><li><p>
					The Consumer exchanges the Request Token for an Access Token. This part is handled by RESTEasy. 
					</p></li></ol></div><p>
				In order for RESTEasy to provide the two URL endpoints where the Client will request unauthorized Request Tokens and exchange authorized Request Tokens
				for Access Tokens, you need to enable the OAuthServlet in your web.xml:
			</p><pre class="programlisting">
				
&lt;!-- The OAuth Servlet handles token exchange --&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;OAuth&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.jboss.RESTEasy.auth.oauth.OAuthServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;!-- This will be the base for the token exchange endpoint URL --&gt;
&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;OAuth&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/oauth/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
				
			</pre><p>
				The following configuration options are available using <code class="code">&lt;context-param&gt; elements</code>:
			</p><table xmlns="" id="d0e2723"><caption>Table 37.1. OAuth Servlet options</caption><thead><tr>
						<th>Option Name</th>
						<th>Default</th>
						<th>Description</th>
					</tr></thead><tbody><tr>
						<td>oauth.provider.provider-class</td>
						<td>*Required*</td>
						<td>Defines the fully-qualified class name of your OAuthProvider implementation</td>
					</tr><tr>
						<td>oauth.provider.tokens.request</td>
						<td>/requestToken</td>
						<td>This defines the endpoint URL for requesting unauthorized Request Tokens</td>
					</tr><tr>
						<td>oauth.provider.tokens.access</td>
						<td>/accessToken</td>
						<td>This defines the endpoint URL for exchanging authorized Request Tokens for Access Tokens</td>
					</tr></tbody></table></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2772"/>37.1.2. Accessing protected resources</h3></div></div></div><p>
				After successfully receiving the Access Token and Token Secret, the Consumer is able to access the Protected Resources on behalf of the User.
			</p><p>
				RESTEasy supports OAuth authentication for protected resources using a servlet filter wich should be mapped in your web.xml for all
				protected resources:
			</p><pre class="programlisting">
				
&lt;!-- The OAuth Filter handles authentication for protected resources --&gt;
&lt;filter&gt;
  &lt;filter-name&gt;OAuth Filter&lt;/filter-name&gt;
  &lt;filter-class&gt;org.jboss.RESTEasy.auth.oauth.OAuthFilter&lt;/filter-class&gt;
&lt;/filter&gt;
	
&lt;!-- This defines the URLs which should require OAuth authentication for your protected resources --&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;OAuth Filter&lt;/filter-name&gt;
  &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
				
			</pre><p>
				The following configuration options are available using <code class="code">&lt;context-param&gt; elements</code>:
			</p><table xmlns="" id="d0e2786"><caption>Table 37.2. OAuth Filter options</caption><thead><tr>
						<th>Option Name</th>
						<th>Default</th>
						<th>Description</th>
					</tr></thead><tbody><tr>
						<td>oauth.provider.provider-class</td>
						<td>*Required*</td>
						<td>Defines the fully-qualified class name of your OAuthProvider implementation</td>
					</tr></tbody></table><p>
				Once authenticated, the OAuth Servlet Filter will set your request's Principal and Roles, which can then be
				accessed using the JAX-RS SecurityContext. You can also protect your resources using Roles as described in the section "Securing JAX-RS and RESTeasy".
			</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2815"/>37.1.3. Implementing an OAuthProvider</h3></div></div></div><p>
				In order for RESTEasy to implement OAuth it needs you to provide an instance of <code class="code">OAuthProvider</code> which
				will provide access to the list of Consumer, Request and Access Tokens. Because one size doesn’t fit all we cannot
				know if you wish to store your Tokens and Consumer credentials in a configuration file, in memory, or on persistent storage.
			</p><p>
				All you need to do is implement the <code class="code">OAuthProvider</code> interface:
			</p><pre class="programlisting">

public interface OAuthProvider {
	String getRealm();

	OAuthConsumer getConsumer(String consumerKey)throws OAuthException;
	OAuthToken getRequestToken(String consumerKey, String requestToken) throws OAuthException;
	OAuthToken getAccessToken(String consumerKey, String accessToken) throws OAuthException;
	
	OAuthToken makeRequestToken(String consumerKey, String callback) throws OAuthException;
	OAuthToken makeAccessToken(String consumerKey, String requestToken, String verifier) throws OAuthException;

	String authoriseRequestToken(String consumerKey, String requestToken) throws OAuthException;

	void checkTimestamp(OAuthToken token, long timestamp) throws OAuthException;
}

			</pre><p>
				If a Consumer Key, or Token doesn’t exist, or if the timestamp is not valid,
				simply throw an <code class="code">OAuthException</code>.
			</p><p>
				The rest of the interfaces used in <code class="code">OAuthProvider</code> are:
			</p><pre class="programlisting">

public interface OAuthConsumer {
	String getKey();
	String getSecret();
}

public interface OAuthToken {
	OAuthConsumer getConsumer();
	String getToken();
	String getSecret();
	Principal getPrincipal();
	Set&lt;String&gt; getRoles();
}

			</pre></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="signature"/>Chapter 38. Digital Signature Framework</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e2934">38.1. Maven settings</a></span></dt><dt><span class="section"><a href="#d0e2942">38.2. Signing API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2953">38.2.1. @Signed annotation</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2967">38.3. Signature Verification API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2983">38.3.1. Annotation-based verification</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e2998">38.4. Managing Keys via a KeyRepository</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3003">38.4.1. Create a KeyStore</a></span></dt><dt><span class="section"><a href="#d0e3016">38.4.2. Configure Restreasy to use the KeyRepository</a></span></dt><dt><span class="section"><a href="#d0e3043">38.4.3. Using DNS to Discover Public Keys</a></span></dt></dl></dd></dl></div><p>Digital signatures allow you to protect the integrity of a message.
  They are used to verify that a message sent was sent by the actual user that
  sent the message and was modified in transit. Most web apps handle message
  integrity by using TLS, like HTTPS, to secure the connection between the
  client and server. Sometimes though, we have representations that are going
  to be forwarded to more than one recipient. Some representations may hop
  around from server to server. In this case, TLS is not enough. There needs
  to be a mechanism to verify who sent the original representation and that
  they actually sent that message. This is where digital signatures come
  in.</p><p>While the mime type multiple/signed exists, it does have drawbacks.
  Most importantly it requires the receiver of the message body to understand
  how to unpack. A receiver may not understand this mime type. A better
  approach would be to put signatures in an HTTP header so that receivers that
  don't need to worry about the digital signature, don't have to.</p><p>The email world has a nice protocol called <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://dkim.org">Domain Keys Identified Mail</a> (DKIM). Work is
  also being done to apply this header to protocols other than email (i.e.
  HTTP) through the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="https://tools.ietf.org/html/draft-crocker-doseta-base-02">DOSETA
  specifications</a>. It allows you to sign a message body and attach the
  signature via a DKIM-Signature header. Signatures are calculated by first
  hashing the message body then combining this hash with an arbitrary set of
  metadata included within the DKIM-Signature header. You can also add other
  request or response headers to the calculation of the signature. Adding
  metadata to the signature calculation gives you a lot of flexiblity to
  piggyback various features like expiration and authorization. Here's what an
  example DKIM-Signature header might look like.</p><pre class="programlisting">DKIM-Signature: v=1;
                a=rsa-sha256;
                d=example.com;
                s=burke;
                c=simple/simple;
                h=Content-Type;
                x=0023423111111;
                bh=2342322111;
                b=M232234=

</pre><p>As you can see it is a set of name value pairs delimited by a ';'.
  While its not THAT important to know the structure of the header, here's an
  explanation of each parameter:</p><div class="variablelist"><dl><dt><span class="term">v</span></dt><dd><p>Protocol version. Always 1.</p></dd><dt><span class="term">a</span></dt><dd><p>Algorithm used to hash and sign the message. RSA signing and
        SHA256 hashing is the only supported algorithm at the moment by
        Resteasy.</p></dd><dt><span class="term">d</span></dt><dd><p>Domain of the signer. This is used to identify the signer as
        well as discover the public key to use to verify the signature.</p></dd><dt><span class="term">s</span></dt><dd><p>Selector of the domain. Also used to identify the signer and
        discover the public key.</p></dd><dt><span class="term">c</span></dt><dd><p>Canonical algorithm. Only simple/simple is supported at the
        moment. Basically this allows you to transform the message body before
        calculating the hash</p></dd><dt><span class="term">h</span></dt><dd><p>Semi-colon dilimited list of headers that are included in the
        signature calculation.</p></dd><dt><span class="term">x</span></dt><dd><p>When the signature expires. This is a numeric long value of the
        time in seconds since epoch. Allows signer to control when a signed
        message's signature expires</p></dd><dt><span class="term">t</span></dt><dd><p>Timestamp of signature. Numeric long value of the time in
        seconds since epoch. Allows the verifier to control when a signature
        expires.</p></dd><dt><span class="term">bh</span></dt><dd><p>Base 64 encoded hash of the message body.</p></dd><dt><span class="term">b</span></dt><dd><p>Base 64 encoded signature.</p></dd></dl></div><p>To verify a signature you need a public key. DKIM uses DNS text
  records to discover a public key. To find a public key, the verifier
  concatenates the Selector (s parameter) with the domain (d parameter)</p><p>&lt;selector&gt;._domainKey.&lt;domain&gt;</p><p>It then takes that string and does a DNS request to retrieve a TXT
  record under that entry. In our above example burke._domainKey.example.com
  would be used as a string. This is a every interesting way to publish public
  keys. For one, it becomes very easy for verifiers to find public keys.
  THere's no real central store that is needed. DNS is a infrastructure IT
  knows how to deploy. Verifiers can choose which domains they allow requests
  from. Resteasy supports discovering public keys via DNS. It also instead
  allows you to discover public keys within a local Java KeyStore if you do
  not want to use DNS. It also allows you to plug in your own mechanism to
  discover keys.</p><p>If you're interested in learning the possible use cases for digital
  signatures, here's a <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://bill.burkecentral.com/2011/02/21/multiple-uses-for-content-signature/">blog</a>
  you might find interesting.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2934"/>38.1. Maven settings</h2></div></div></div><p>You must include the resteasy-doseta project to use the digital
    signature framework.</p><pre class="programlisting">        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
            &lt;artifactId&gt;resteasy-doseta&lt;/artifactId&gt;
            &lt;version&gt;2.2.1.GA&lt;/version&gt;
        &lt;/dependency&gt;

</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2942"/>38.2. Signing API</h2></div></div></div><p>To sign a request or response using the Resteasy client or server
    framework you need to create an instance of
    org.jboss.resteasy.security.doseta.DKIMSignature. This class represents
    the DKIM-Signature header. You instantiate the DKIMSignature object and
    then set the "DKIM-Signature" header of the request or response. Here's an
    example of using it on the server-side:</p><pre class="programlisting">import org.jboss.resteasy.security.doseta.DKIMSignature;
import java.security.PrivateKey;


@Path("/signed")
public static class SignedResource
{
   @GET
   @Path("manual")
   @Produces("text/plain")
   public Response getManual()
   {
      PrivateKey privateKey = ....; // get the private key to sign message
      
      DKIMSignature signature = new DKIMSignature();
      signature.setSelector("test");
      signature.setDomain("samplezone.org");
      signature.setPrivateKey(privateKey);

      Response.ResponseBuilder builder = Response.ok("hello world");
      builder.header(DKIMSignature.DKIM_SIGNATURE, signature);
      return builder.build();
   }
}

// client example

DKIMSignature signature = new DKIMSignature();
PrivateKey privateKey = ...; // go find it
signature.setSelector("test");
signature.setDomain("samplezone.org");
signature.setPrivateKey(privateKey);

ClientRequest request = new ClientRequest("http://...");
request.header("DKIM-Signature", signature);
request.body("text/plain", "some body to sign");
ClientResponse response = request.put();
</pre><p>To sign a message you need a PrivateKey. This can be
    generated by KeyTool or manually using regular, standard JDK Signature
    APIs. Resteasy currently only supports RSA key pairs. The DKIMSignature
    class also allows you to add and control how various pieces of metadata
    are added to the DKIM-Signature header and the signature calculation. See
    the javadoc for more details.</p><p>If you are including more than one signature, then just add
    additional DKIMSignature instances to the headers of the request or
    response.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2953"/>38.2.1. @Signed annotation</h3></div></div></div><p>Instead of using the API, Resteasy also provides you an
      annotationAn alternative to the manual way of signing using a
      DKIMSignature instances is to use the
      @org.jboss.resteasy.annotations.security.doseta.Signed annotation. It is
      required that you configure a KeyRepository as described later in this
      chapter. Here's an example:</p><pre class="programlisting">   @GET
   @Produces("text/plain")
   @Path("signedresource")
   @Signed(selector="burke", domain="sample.com", timestamped=true, expires=@After(hours=24))
   public String getSigned()
   {
      return "hello world";
   }

</pre><p>The above example using a bunch of the optional annotation
      attributes of @Signed to create the following Content-Signature
      header:</p><pre class="programlisting">DKIM-Signature: v=1;
                a=rsa-sha256;
                c=simple/simple;
                domain=sample.com;
                s=burke;
                t=02342342341;
                x=02342342322;
                bh=m0234fsefasf==;
                b=mababaddbb==
   
</pre><p><em class="parameter"><code>This annotation also works with the client proxy
      framework.</code></em></p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2967"/>38.3. Signature Verification API</h2></div></div></div><p>If you want fine grain control over verification, this is an API to
    verify signatures manually. Its a little tricky because you'll need the
    raw bytes of the HTTP message body in order to verify the signature. You
    can get at an unmarshalled message body as well as the underlying raw
    bytes by using a org.jboss.resteasy.spi.MarshalledEntity injection. Here's
    an example of doing this on the server side:</p><pre class="programlisting">import org.jboss.resteasy.spi.MarshalledEntity;


@POST
@Consumes("text/plain")
@Path("verify-manual")
public void verifyManual(@HeaderParam("Content-Signature") DKIMSignature signature,
                         @Context KeyRepository repository, 
                         @Context HttpHeaders headers, 
                         MarshalledEntity&lt;String&gt; input) throws Exception
{
      Verifier verifier = new Verifier();
      Verification verification = verifier.addNew();
      verification.setRepository(repository);
      verification.setStaleCheck(true);
      verification.setStaleSeconds(100);
      try {
          verifier.verifySignature(headers.getRequestHeaders(), input.getMarshalledBytes, signature);
      } catch (SignatureException ex) {
      }
      System.out.println("The text message posted is: " + input.getEntity());
}
</pre><p>MarshalledEntity is a generic interface. The template
    parameter should be the Java type you want the message body to be
    converted into. You will also have to configure a KeyRepository. This is
    describe later in this chapter.</p><p>The cient side is a little bit different:</p><pre class="programlisting">ClientRequest request = new ClientRequest("http://localhost:9095/signed"));


ClientResponse&lt;String&gt; response = request.get(String.class);
Verifier verifier = new Verifier();
Verification verification = verifier.addNew();
verification.setRepository(repository);
response.getProperties().put(Verifier.class.getName(), verifier);

// signature verification happens when you get the entity
String entity = response.getEntity();

</pre><p><em class="parameter"><code>On the client side, you create a verifier and add
    it as a property to the ClientResponse. This will trigger the verification
    interceptors.</code></em></p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2983"/>38.3.1. Annotation-based verification</h3></div></div></div><p>The easiest way to verify a signature sent in a HTTP request on
      the server side is to use the
      @@org.jboss.resteasy.annotations.security.doseta.Verify (or
      @Verifications which is used to verify multilpe signatures). Here's an
      example:</p><pre class="programlisting">      @POST
      @Consumes("text/plain")
      @Verify
      public void post(String input)
      {
      }

</pre><p>In the above example, any DKIM-Signature headers attached to
      the posted message body will be verified. The public key to verify is
      discovered using the configured KeyRepository (discussed later in this
      chapter). You can also specify which specific signatures you want to
      verify as well as define multiple verifications you want to happen via
      the @Verifications annoation. Here's a complex example:</p><pre class="programlisting">@POST
@Consumes("text/plain")
@Verifications(
   @Verify(identifierName="d", identiferValue="inventory.com", stale=@After(days=2)),
   @Verify(identifierName="d", identiferValue="bill.com")
}
public void post(String input) {...}
</pre><p>The above is expecting 2 different signature to be included
      within the DKIM-Signature header.</p><p>Failed verifications will throw an
      org.jboss.resteasy.security.doseta.UnauthorizedSignatureException. This
      causes a 401 error code to be sent back to the client. If you catch this
      exception using an ExceptionHandler you can browse the failure
      results.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2998"/>38.4. Managing Keys via a KeyRepository</h2></div></div></div><p>Resteasy manages keys for you through a
    org.jboss.resteasy.security.doseta.KeyRepository. By default, the
    KeyRepository is backed by a Java KeyStore. Private keys are always
    discovered by looking into this KeyStore. Public keys may also be
    discovered via a DNS text (TXT) record lookup if configured to do so. You
    can also implement and plug in your own implementation of
    KeyRepository.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3003"/>38.4.1. Create a KeyStore</h3></div></div></div><p>Use the Java keytool to generate RSA key pairs. Key aliases MUST
      HAVE the form of:</p><p>&lt;selector&gt;._domainKey.&lt;domain&gt;</p><p>For example:</p><pre class="programlisting">$ keytool -genkeypair -alias burke._domainKey.example.com -keyalg RSA -keysize 1024 -keystore my-apps.jks </pre><p>You
      can always import your own offical certificates too. See the JDK
      documentation for more details.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3016"/>38.4.2. Configure Restreasy to use the KeyRepository</h3></div></div></div><p>Next you need to configure the KeyRepository in your web.xml file
      so that it is created and made available to Resteasy to discover private
      and public keys.You can reference a Java key store you want the Resteasy
      signature framework to use within web.xml using either
      <code class="literal">resteasy.keystore.classpath</code> or
      <code class="literal">resteasy.keystore.filename</code> context parameters. You
      must also specify the password (sorry its clear text) using the
      <code class="literal">resteasy.keystore.password</code> context parameter. The
      resteasy.context.objects is used to create the instance of the
      repository. For example:</p><pre class="programlisting">    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.doseta.keystore.classpath&lt;/param-name&gt;
        &lt;param-value&gt;test.jks&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.doseta.keystore.password&lt;/param-name&gt;
        &lt;param-value&gt;geheim&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.context.objects&lt;/param-name&gt;
        &lt;param-value&gt;org.jboss.resteasy.security.doseta.KeyRepository : org.jboss.resteasy.security.doseta.ConfiguredDosetaKeyRepository&lt;/param-value&gt;
    &lt;/context-param&gt;

</pre><p>You can also manually register your own instance of a
      KeyRepository within an Application class. For example:</p><pre class="programlisting">import org.jboss.resteasy.core.Dispatcher;
import org.jboss.resteasy.security.doseta.KeyRepository;
import org.jboss.resteasy.security.doseta.DosetaKeyRepository;

import javax.ws.rs.core.Application;
import javax.ws.rs.core.Context;

public class SignatureApplication extends Application
{
   private HashSet&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;Class&lt;?&gt;&gt;();
   private KeyRepository repository;

   public SignatureApplication(@Context Dispatcher dispatcher)
   {
      classes.add(SignedResource.class);

      repository = new DosetaKeyRepository();
      repository.setKeyStorePath("test.jks");
      repository.setKeyStorePassword("password");
      repository.setUseDns(false);
      repository.start();

      dispatcher.getDefaultContextObjects().put(KeyRepository.class, repository);
   }

   @Override
   public Set&lt;Class&lt;?&gt;&gt; getClasses()
   {
      return classes;
   }
}

</pre><p>On the client side, you can load a KeyStore manually, by
      instantiating an instance of
      org.jboss.resteasy.security.doseta.DosetaKeyRepository. You then set a
      request attribute, "org.jboss.resteasy.security.doseta.KeyRepository",
      with the value of the created instance. Use the
      ClientRequest.getAttributes() method to do this. For example:</p><pre class="programlisting">DosetaKeyRepository keyRepository = new DoestaKeyRepository();
repository.setKeyStorePath("test.jks");
repository.setKeyStorePassword("password");
repository.setUseDns(false);
repository.start();

DKIMSignature signature = new DKIMSignature();
signature.setDomain("example.com");

ClientRequest request = new ClientRequest("http://...");
request.getAttributes().put(KeyRepository.class.getName(), repository);
request.header("DKIM-Signature", signatures);
</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3043"/>38.4.3. Using DNS to Discover Public Keys</h3></div></div></div><p>Public keys can also be discover by a DNS text record lookup. You
      must configure web.xml to turn this feature:</p><pre class="programlisting">    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.doseta.use.dns&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.doseta.dns.uri&lt;/param-name&gt;
        &lt;param-value&gt;dns://localhost:9095&lt;/param-value&gt;
    &lt;/context-param&gt;

</pre><p>The resteasy.doseta.dns.uri context-param is optional and
      allows you to point to a specific DNS server to locate text
      records.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3052"/>38.4.3.1. Configuring DNS TXT Records</h4></div></div></div><p>DNS TXT Records are stored via a format described by the DOSETA
        specification. The public key is defined via a base 64 encoding. You
        can obtain this text encoding by exporting your public keys from your
        keystore, then using a tool like openssl to get the text-based format.
        For example:</p><pre class="programlisting">$ keytool -export -alias bill._domainKey.client.com -keystore client.jks -file bill.der 
$ openssl x509 -noout -pubkey -in bill.der -inform der &gt; bill.pem</pre><p>The
        output will look something like: </p><pre class="programlisting">-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCKxct5GHz8dFw0mzAMfvNju2b3
oeAv/EOPfVb9mD73Wn+CJYXvnryhqo99Y/q47urWYWAF/bqH9AMyMfibPr6IlP8m
O9pNYf/Zsqup/7oJxrvzJU7T0IGdLN1hHcC+qRnwkKddNmD8UPEQ4BXiX4xFxbTj
NvKWLZVKGQMyy6EFVQIDAQAB
-----END PUBLIC KEY-----
</pre><p>The DNS text record entry would look like this:</p><pre class="programlisting">test2._domainKey        IN      TXT     "v=DKIM1; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCIKFLFWuQfDfBug688BJ0dazQ/x+GEnH443KpnBK8agpJXSgFAPhlRvf0yhqHeuI+J5onsSOo9Rn4fKaFQaQNBfCQpHSMnZpBC3X0G5Bc1HWq1AtBl6Z1rbyFen4CmGYOyRzDBUOIW6n8QK47bf3hvoSxqpY1pHdgYoVK0YdIP+wIDAQAB; t=s"
</pre><p>Notice that the newlines are take out. Also, notice that the
        text record is a name value ';' delimited list of parameters. The p
        field contains the public key.</p></div></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="RESTEasy_EJB_Integration"/>Chapter 39. EJB Integration</h2></div></div></div><p>

To integrate with EJB you must first modify your EJB's published interfaces.  Resteasy currently only has simple portable integration with EJBs so you must also manually configure your Resteasy WAR.
</p><p>


</p><p>

Resteasy currently only has simple integration with EJBs.  To make an EJB a JAX-RS resource, you must annotate an SLSB's @Remote or @Local interface with JAX-RS annotations:
</p><p>

</p><pre class="programlisting">
@Local
@Path("/Library")
public interface Library {
   
   @GET
   @Path("/books/{isbn}")
   public String getBook(@PathParam("isbn") String isbn);
}

@Stateless
public class LibraryBean implements Library {

...

}
</pre><p>
</p><p>

</p><p>


</p><p>

Next, in RESTeasy's web.xml file you must manually register the EJB with RESTeasy using the resteasy.jndi.resources &lt;context-param&gt;
</p><p>

</p><pre class="programlisting">
&lt;web-app&gt;
   &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
   &lt;context-param&gt;
      &lt;param-name&gt;resteasy.jndi.resources&lt;/param-name&gt;
      &lt;param-value&gt;LibraryBean/local&lt;/param-value&gt;
   &lt;/context-param&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</pre><p>
</p><p>

This is the only portable way we can offer EJB integration.  Future versions of RESTeasy will have tighter integration with JBoss AS so you do not have to do any manual registrations or modications to web.xml.  For right now though, we're focusing on portability.
</p><p>

</p><p>


</p><p>

If you're using Resteasy with an EAR and EJB, a good structure to have is:
</p><p>

</p><pre class="programlisting">
my-ear.ear
|------myejb.jar
|------resteasy-jaxrs.war
       |
       ----WEB-INF/web.xml
       ----WEB-INF/lib (nothing)
|------lib/
       |
       ----All Resteasy jar files
</pre><p>
</p><p>

From the distribution, remove all libraries from WEB-INF/lib and place them in a common EAR lib.  OR.  Just place the Resteasy jar dependencies in your application server's system classpath.  (i.e. In JBoss put them in server/default/lib)
</p><p>

An example EAR project is available from our testsuite here.
</p><p>


</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="RESTEasy_Spring_Integration"/>Chapter 40. Spring Integration</h2></div></div></div><p>

RESTEasy integrates with Spring 3.0.x.  We are interested in other forms of Spring integration, so please help contribute.
</p><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="SpringBeanProcessor"/>40.1. Basic Integration</h3></div></div></div><p>For Maven users, you must use the resteasy-spring artifact.  Otherwise, the jar is available in the downloaded distribution.
</p><pre class="programlisting">

&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
    &lt;artifactId&gt;resteasy-spring&lt;/artifactId&gt;
    &lt;version&gt;whatever version you are using&lt;/version&gt;
&lt;/dependency&gt;

</pre><p>
RESTeasy comes with its own Spring ContextLoaderListener that registers a RESTeasy specific BeanPostProcessor that processes JAX-RS annotations when a bean is created by a BeanFactory.  What does this mean?  RESTeasy will automatically scan for @Provider and JAX-RS resource annotations on your bean class and register them as JAX-RS resources.
</p><p> Here is what you have to do with your web.xml file</p><pre class="programlisting">
&lt;web-app&gt;
   &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap&lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;org.jboss.resteasy.plugins.spring.SpringContextLoaderListener&lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;


&lt;/web-app&gt;
</pre><p>

The SpringContextLoaderListener must be declared after ResteasyBootstrap as it uses ServletContext attributes initialized by it.
</p><p>

If you do not use a Spring ContextLoaderListener to create your bean factories, then you can manually register the RESTeasy BeanFactoryPostProcessor by allocating an instance of org.jboss.resteasy.plugins.spring.SpringBeanProcessor.  You can obtain instances of a ResteasyProviderFactory and Registry from the ServletContext attributes org.jboss.resteasy.spi.ResteasyProviderFactory and org.jboss.resteasy.spi.Registry.  (Really the string FQN of these classes).  There is also a org.jboss.resteasy.plugins.spring.SpringBeanProcessorServletAware, that will automatically inject references to the Registry and ResteasyProviderFactory from the Servlet Context.  (that is, if you have used RestasyBootstrap to bootstrap Resteasy).
</p><p>
   Our Spring integration supports both singletons and the "prototype" scope.  RESTEasy handles injecting @Context references.  Constructor injection is not supported though.  Also, with the "prototype" scope, RESTEasy will inject any @*Param annotated fields or setters before the request is dispatched.
</p><p>
</p><p>
NOTE: You can only use auto-proxied beans with our base Spring integration.   You will have undesirable affects if you are doing handcoded proxying with Spring, i.e., with ProxyFactoryBean.  If you are using auto-proxied beans, you will be ok.
</p></div><div class="sect2" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="SpringMVC"/>40.2. Spring MVC Integration</h3></div></div></div><p> 
      RESTEasy can also integrate with the Spring DispatcherServlet.  The advantages of using this are that you have a simpler web.xml file, you can dispatch to either Spring controllers or Resteasy from under the same base URL, and finally, the most important, you can use Spring ModelAndView objects as return arguments from @GET resource methods.  Setup requires you using the Spring DispatcherServlet in your web.xml file, as well as importing the springmvc-resteasy.xml file into your base Spring beans xml file.   Here's an example web.xml file:
   </p><pre class="programlisting">
&lt;web-app&gt;
   &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

   &lt;servlet&gt;
      &lt;servlet-name&gt;Spring&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet;&lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Spring&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;


&lt;/web-app&gt;
</pre><p>Then within your main Spring beans xml, import the springmvc-resteasy.xml file</p><pre class="programlisting">

&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
"&gt;

    &lt;!-- Import basic SpringMVC Resteasy integration --&gt;
    &lt;import resource="classpath:springmvc-resteasy.xml"/&gt;
....

</pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="CDI"/>Chapter 41. CDI Integration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e3157">41.1. Using CDI beans as JAX-RS components</a></span></dt><dt><span class="section"><a href="#d0e3172">41.2. Default scopes</a></span></dt><dt><span class="section"><a href="#d0e3193">41.3. Configuration within JBoss 6 M4 and Higher</a></span></dt><dt><span class="section"><a href="#d0e3198">41.4. Configuration with different distributions</a></span></dt></dl></div><p>This module provides integration with JSR-299 (Contexts and
        Dependency Injection for the Java EE platform)
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3157"/>41.1. Using CDI beans as JAX-RS components</h2></div></div></div><p>
            Both the JAX-RS and CDI specifications introduce their own
            component
            model. On the one hand, every class placed in a CDI archive that
            fulfills a set of basic constraints is implicitly a CDI bean. On
            the
            other hand, explicit decoration of your Java class with
            <code class="code">@Path</code>
            or
            <code class="code">@Provider</code>
            is required for it to become a JAX-RS component.
            Without the
            integration code, annotating a class suitable for being a CDI bean
            with
            JAX-RS annotations leads into a faulty result (JAX-RS component
            not managed by CDI)
            The
            resteasy-cdi module is a bridge that
            allows
            RESTEasy
            to work with class
            instances obtained from the CDI
            container.
        </p><p>
            During a
            web
            service
            invocation, resteasy-cdi asks the CDI
            container
            for the
            managed
            instance
            of a JAX-RS component. Then, this
            instance is
            passed
            to
            RESTEasy.
            If a
            managed instance is not available for
            some
            reason (the
            class is
            placed
            in a jar which is not a bean deployment
            archive),
            RESTEasy
            falls back to
            instantiating the class itself.
        </p><p>
            As a result, CDI services like injection, lifecycle management,
            events, decoration and interceptor bindings can be used in JAX-RS
            components.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3172"/>41.2. Default scopes</h2></div></div></div><p>
            A CDI bean that does not explicitly define a scope is
            <code class="code">@Dependent</code>
            scoped by default.
            This pseudo scope means that the bean adapts to the
            lifecycle of
            the bean it is
            injected into. Normal scopes (request,
            session,
            application) are more suitable for JAX-RS components as they
            designate component's lifecycle boundaries explicitly. Therefore, the
            resteasy-cdi
            module alters the default
            scoping in
            the following way:
        </p><div class="itemizedlist"><ul><li><p>
                    If a JAX-RS root resource does not define a scope
                    explicitly,
                    it is
                    bound to the Request scope.
                </p></li><li><p>
                    If a JAX-RS Provider or
                    <code class="code">javax.ws.rs.Application</code>
                    subclass
                    does not define a scope explicitly, it is bound to the
                    Application
                    scope.
                </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>
                Since the scope of all beans that do not declare a scope is
                modified by resteasy-cdi, this affects session beans as well. As a
                result, a conflict occurs if the scope of a stateless session bean
                or singleton is changed automatically as the spec prohibits these
                components to
                be @RequestScoped.
                Therefore, you
                need to explicitly
                define a scope
                when using stateless session
                beans or singletons. This
                requirement is likely to
                be removed in
                future releases.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3193"/>41.3. Configuration within JBoss 6 M4 and Higher</h2></div></div></div><p>
            CDI integration is provided with no additional configuration with JBoss AS 6-M4 and higher.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3198"/>41.4. Configuration with different distributions</h2></div></div></div><p>
            Provided you have an
            existing RESTEasy application, all that needs to
            be done is to
            add the
            resteasy-cdi jar into your project's
            <code class="code">WEB-INF/lib</code>
            directory.
            When using
            maven, this can be achieve by defining the
            following
            dependency.
            </p><pre class="programlisting">&lt;dependency&gt;
	&lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
	&lt;artifactId&gt;resteasy-cdi&lt;/artifactId&gt;
	&lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
        </p><p>
            Furthermore, when running a pre-Servlet 3 container, the
            following context parameter needs to be specified in web.xml. (This
            is done
            automatically via web-fragment in a Servlet 3 environment)
        </p><pre class="programlisting">&lt;context-param&gt;
	&lt;param-name&gt;resteasy.injector.factory&lt;/param-name&gt;
	&lt;param-value&gt;org.jboss.resteasy.cdi.CdiInjectorFactory&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>
            When deploying an application to a Servlet container that does not
            support CDI out of the box
            (Tomcat, Jetty, Google App Engine), a CDI implementation needs to be
            added first.
            <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/weld/reference/latest/en-US/html/environments.html">Weld-servlet module
            </a>
            can be used for this purpose.
        </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Seam"/>Chapter 42. Seam Integration</h2></div></div></div><p>RESTEasy integrates quite nicely with the JBoss Seam framework.  This integration is maintained
    by the Seam developers and documented there as well.  Check out <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://docs.jboss.org/seam/latest/en-US/html/webservices.html#d0e22078">Seam documentation</a>.</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Guice1"/>Chapter 43. Guice 2.0 Integration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e3243">43.1. Configuring Stage</a></span></dt></dl></div><p>RESTEasy has some simple integration with Guice 2.0.  RESTEasy will scan the binding types for a Guice Module
        for @Path and @Provider annotations.  It will register these bindings with RESTEasy.  The guice-hello
    project that comes in the RESTEasy examples/ directory gives a nice example of this.</p><pre class="programlisting">
@Path("hello")
public class HelloResource
{
   @GET
   @Path("{name}")
   public String hello(@PathParam("name") final String name) {
      return "Hello " + name;
   }
}
</pre><p>First you start off by specifying a JAX-RS resource class.  The HelloResource is just that.  Next you
    create a Guice Module class that defines all your bindings:</p><pre class="programlisting">
import com.google.inject.Module;
import com.google.inject.Binder;

public class HelloModule implements Module
{
    public void configure(final Binder binder)
    {
       binder.bind(HelloResource.class);
    }
}
</pre><p>You put all these classes somewhere within your WAR WEB-INF/classes or in a JAR within WEB-INF/lib.  Then
    you need to create your web.xml file.  You need to use the GuiceResteasyBootstrapServletContextListener as
    follows</p><pre class="programlisting">

&lt;web-app&gt;
    &lt;display-name&gt;Guice Hello&lt;/display-name&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.guice.modules&lt;/param-name&gt;
        &lt;param-value&gt;org.jboss.resteasy.examples.guice.hello.HelloModule&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;
            org.jboss.resteasy.plugins.guice.GuiceResteasyBootstrapServletContextListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

</pre><p>GuiceResteasyBootstrapServletContextListener is a subclass of ResteasyBootstrap, so you can use
    any other RESTEasy configuration option within your web.xml file.  Also notice that there is a
    resteasy.guice.modules context-param.  This can take a comma delimited list of class names that
    are Guice Modules.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3243"/>43.1. Configuring Stage</h2></div></div></div><p>
            You can configure the stage Guice uses to deploy your modules by specific a context param, resteasy.guice.stage.
            If this value is not specified, Resteasy uses whatever Guice's default is.
        </p><pre class="programlisting">

&lt;web-app&gt;
    &lt;display-name&gt;Guice Hello&lt;/display-name&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.guice.modules&lt;/param-name&gt;
        &lt;param-value&gt;org.jboss.resteasy.examples.guice.hello.HelloModule&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.guice.stage&lt;/param-name&gt;
        &lt;param-value&gt;PRODUCTION&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;listener&gt;
        &lt;listener-class&gt;
            org.jboss.resteasy.plugins.guice.GuiceResteasyBootstrapServletContextListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher
        &lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;

</pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="RESTEasy_Client_Framework"/>Chapter 44. Client Framework</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#Custom_client-side_responses">44.1. Abstract Responses</a></span></dt><dt><span class="sect1"><a href="#Sharing_interfaces">44.2. Sharing an interface between client and server</a></span></dt><dt><span class="sect1"><a href="#Client_error_handling">44.3. Client Error Handling</a></span></dt><dt><span class="sect1"><a href="#ClientRequest">44.4. Manual ClientRequest API</a></span></dt><dt><span class="sect1"><a href="#spring_client_proxy">44.5. Spring integration on client side</a></span></dt></dl></div><p>

        The Resteasy Client Framework is the mirror opposite of the JAX-RS server-side specification. Instead of using
        JAX-RS annotations to map an incoming request to your RESTFul Web Service method, the client framework builds an
        HTTP request that it uses to invoke on a remote RESTful Web Service. This remote service does not have to be a
        JAX-RS service and can be any web resource that accepts HTTP requests.
    </p><p>

        Resteasy has a client proxy framework that allows you to use JAX-RS annotations to invoke on a remote HTTP
        resource.
        The way it works is that you write a Java interface and use JAX-RS annotations on methods and the interface. For
        example:
    </p><p>

</p><pre class="programlisting">
public interface SimpleClient
{
   @GET
   @Path("basic")
   @Produces("text/plain")
   String getBasic();

   @PUT
   @Path("basic")
   @Consumes("text/plain")
   void putBasic(String body);

   @GET
   @Path("queryParam")
   @Produces("text/plain")
   String getQueryParam(@QueryParam("param")String param);

   @GET
   @Path("matrixParam")
   @Produces("text/plain")
   String getMatrixParam(@MatrixParam("param")String param);

   @GET
   @Path("uriParam/{param}")
   @Produces("text/plain")
   int getUriParam(@PathParam("param")int param);
}</pre><p>
    </p><p>

        Resteasy has a simple API based on Apache HttpClient. You generate a proxy then you can invoke methods on the
        proxy. The invoked method gets translated to an HTTP request based on how you annotated the method and posted to
        the server. Here's how you would set this up:
    </p><p>

        </p><pre class="programlisting">
            import org.jboss.resteasy.client.ProxyFactory;
            ...
            // this initialization only needs to be done once per VM
            RegisterBuiltin.register(ResteasyProviderFactory.getInstance());


            SimpleClient client = ProxyFactory.create(SimpleClient.class, "http://localhost:8081");
            client.putBasic("hello world");
        </pre><p>
    </p><p>

        Please see the ProxyFactory javadoc for more options. For instance, you may want to fine tune the HttpClient
        configuration.
    </p><p>


    </p><p>

        @CookieParam works the mirror opposite of its server-side counterpart and creates a cookie header to send to the
        server. You do not need to use @CookieParam if you allocate your own javax.ws.rs.core.Cookie object and pass it
        as
        a parameter to a client proxy method. The client framework understands that you are passing a cookie to the
        server
        so no extra metadata is needed.
    </p><p>


    </p><p>

        The client framework can use the same providers available on the server. You must manually register them through
        the ResteasyProviderFactory singleton using the addMessageBodyReader() and addMessageBodyWriter() methods.
    </p><pre class="programlisting">
        ResteasyProviderFactory.getInstance().addMessageBodyReader(MyReader.class);
    </pre><p>


    </p><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Custom_client-side_responses"/>44.1. Abstract Responses</h2></div></div></div><p>

            Sometimes you are interested not only in the response body of a client request, but also either the response
            code and/or response headers. The Client-Proxy framework has two ways to get at this information
        </p><p>


        </p><p>

            You may return a javax.ws.rs.core.Response.Status enumeration from your method calls:
        </p><p>

            </p><pre class="programlisting">
@Path("/")
public interface MyProxy {
   @POST
   Response.Status updateSite(MyPojo pojo);
}
            </pre><p>
        </p><p>

            Interally, after invoking on the server, the client proxy internals will convert the HTTP response code into
            a
            Response.Status enum.
        </p><p>


        </p><p>

            If you are interested in everything, you can get it with the org.jboss.resteasy.spi.ClientResponse interface:
        </p><pre class="programlisting">
/**
 * Response extension for the RESTEasy client framework. Use this, or Response
 * in your client proxy interface method return type declarations if you want
 * access to the response entity as well as status and header information.
 *
 * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
 * @version $Revision: 1 $
 */
public abstract class ClientResponse&lt;T&gt; extends Response
{
   /**
    * This method returns the same exact map as Response.getMetadata() except as a map of strings 
    * rather than objects.
    *
    * @return
    */
   public abstract MultivaluedMap&lt;String, String&gt; getHeaders();

   public abstract Response.Status getResponseStatus();

   /**
    * Unmarshal the target entity from the response OutputStream.  You must have type information
    * set via &lt;T&gt; otherwise, this will not work.
    * &lt;p/&gt;
    * This method actually does the reading on the OutputStream.  It will only do the read once.  
    * Afterwards, it will cache the result and return the cached result.
    *
    * @return
    */
   public abstract T getEntity();

   /**
    * Extract the response body with the provided type information
    * &lt;p/&gt;
    * This method actually does the reading on the OutputStream.  It will only do the read once.  
    * Afterwards, it will cache the result and return the cached result.
    *
    * @param type
    * @param genericType
    * @param &lt;T2&gt;
    * @return
    */
   public abstract &lt;T2&gt; T2 getEntity(Class&lt;T2&gt; type, Type genericType);

   /**
    * Extract the response body with the provided type information.  GenericType is a trick used to
    * pass in generic type information to the resteasy runtime.
    * &lt;p/&gt;
    * For example:
    * &lt;pre&gt;
    * List&lt;String&gt; list = response.getEntity(new GenericType&lt;List&lt;String&gt;() {});
    * &lt;p/&gt;
    * &lt;p/&gt;
    * This method actually does the reading on the OutputStream.  It will only do the read once.  Afterwards, it will
    * cache the result and return the cached result.
    *
    * @param type
    * @param &lt;T2&gt;
    * @return
    */
   public abstract &lt;T2&gt; T2 getEntity(GenericType&lt;T2&gt; type);
}

        </pre><p>
            All the getEntity() methods are deferred until you invoke them. In other words, the response OutputStream is
            not read
            until you call one of these methods. The empty paramed getEntity() method can only be used if you have
            templated the ClientResponse within your method declaration. Resteasy uses this generic type information to
            know what type to unmarshal the raw OutputStream into. The other two getEntity() methods that take
            parameters, allow you to specify which Object types you want to marshal the response into. These methods
            allow you to dynamically extract whatever types you want at runtime. Here's an example:
        </p><p>

            </p><pre class="programlisting">
@Path("/")
public interface LibraryService {

   @GET
   @Produces("application/xml")
   ClientResponse&lt;LibraryPojo&gt; getAllBooks();
}</pre><p>
        </p><p>

            We need to include the LibraryPojo in ClientResponse's generic declaration so that the client proxy
            framework
            knows how to unmarshal the HTTP response body.
        </p><p>


        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Sharing_interfaces"/>44.2. Sharing an interface between client and server</h2></div></div></div><p>
            It is generally possible to share an interface between the client and server. In this scenario, you just
            have your JAX-RS services implement an annotated interface
            and then reuse that same interface to create client proxies to invoke on on the client-side. One caveat to
            this is when your JAX-RS methods return a Response object.
            The problem on the client is that the client does not have any type information with a raw Response return
            type declaration. There are two ways of getting around
            this. The first is to use the @ClientResponseType annotation.
        </p><pre class="programlisting">
import org.jboss.resteasy.annotations.ClientResponseType;
import javax.ws.rs.core.Response;

@Path("/")
public interface MyInterface {

   @GET
   @ClientResponseType(String.class)
   @Produces("text/plain")
   public Response get();
}</pre><p>
            This approach isn't always good enough. The problem is that some MessageBodyReaders and Writers need generic
            type information in order to match and service a request.
        </p><pre class="programlisting">
@Path("/")
public interface MyInterface {

   @GET
   @Produces("application/xml")
   public Response getMyListOfJAXBObjects();
}</pre><p>
            In this case, your client code can cast the returned Response object to a ClientResponse and use one of the
            typed getEntity() methods.
        </p><pre class="programlisting">
MyInterface proxy = ProxyFactory.create(MyInterface.class, "http://localhost:8081");
ClientResponse response = (ClientResponse)proxy.getMyListOfJAXBObjects();
List&lt;MyJaxbClass&gt; list = response.getEntity(new GenericType&lt;List&lt;MyJaxbClass&gt;&gt;());
</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Client_error_handling"/>44.3. Client Error Handling</h2></div></div></div><p>

            If you are using the Client Framework and your proxy methods return something other than a
            ClientResponse, then the default client error handling comes into play. Any response code that is greater
            tha
            399 will automatically cause a org.jboss.resteasy.client.ClientResponseFailure exception
        </p><p>

</p><pre class="programlisting">
   @GET
   ClientResponse&lt;String&gt; get() // will throw an exception if you call getEntity()

   @GET
   MyObject get(); // will throw a ClientResponseFailure on response code &gt; 399
</pre><p>
        </p><p>
		In cases where Client Proxy methods do not return Response or
		ClientResponse, it may be not be desireable for the Client Proxy
		Framework to throw generic ClientResponseFailure exceptions. In these
		scenarios, where more fine-grained control of thrown Exceptions is
		required, the ClientErrorInterceptor API may be used.
		</p><pre class="programlisting">
public static T getClientService(final Class clazz, final String serverUri)
{
	ResteasyProviderFactory pf = ResteasyProviderFactory.getInstance();
	pf.addClientErrorInterceptor(new DataExceptionInterceptor());

	System.out.println("Generating REST service for: " + clazz.getName());
	return ProxyFactory.create(clazz, serverUri);
}
</pre><p>
	ClientErrorInterceptor provides a hook into the proxy ClientResponse request lifecycle. If a
	Client Proxy method is called, resulting in a client exception, and the
	proxy return type is not Response or ClientResponse, registered
	interceptors will be given a chance to process the response manually,
	or throw a new exception. If all interceptors successfully return,
	RestEasy will re-throw the original encountered exception. Note,
	however, that the response input stream may need to be reset before
	additional reads will succeed.
</p><pre class="programlisting">
public class ExampleInterceptor implements ClientErrorInterceptor
{
	public void handle(ClientResponse response) throws RuntimeException
	{
		try
		{
			BaseClientResponse r = (BaseClientResponse) response;
			InputStream stream = r.getStreamFactory().getInputStream();
			stream.reset();
			
			String data = response.getEntity(String.class);
		
		
			if(FORBIDDEN.equals(response.getResponseStatus()))
			{
				throw new MyCustomException("This exception will be thrown "
					+ "instead of the ClientResponseFailure");
			}
		
		}
		catch (IOException e)
		{
			//...
		}
		// If we got here, and this method returns successfully, 
		// RESTEasy will throw the original ClientResponseFailure
	}
}
</pre><p>
		
		
        </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="ClientRequest"/>44.4. Manual ClientRequest API</h2></div></div></div><p>Resteasy has a manual API for invoking requests:  org.jboss.resteasy.client.ClientRequest  See the Javadoc for the full capabilities
    of this class.  Here is a simple example:</p><pre class="programlisting">

   ClientRequest request = new ClientRequest("http://localhost:8080/some/path");
   request.header("custom-header", "value");

   // We're posting XML and a JAXB object
   request.body("application/xml", someJaxb);

   // we're expecting a String back
   ClientResponse&lt;String&gt; response = request.post(String.class);
   
   if (response.getStatus() == 200) // OK!
   {
      String str = response.getEntity();
   }
</pre></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="spring_client_proxy"/>44.5. Spring integration on client side</h2></div></div></div><p>
            When using spring you can generate a REST client proxy from an interface
            with the help of org.jboss.resteasy.client.spring.RestClientProxyFactoryBean.
        </p><pre class="programlisting">
&lt;bean id="echoClient" class="org.jboss.resteasy.client.spring.RestClientProxyFactoryBean"
    p:serviceInterface="a.b.c.Echo" p:baseUri="http://server.far.far.away:8080/echo" /&gt;
</pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="AJAX_Client"/>Chapter 45. AJAX Client</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e3371">45.1. Generated JavaScript API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3387">45.1.1. JavaScript API servlet</a></span></dt><dt><span class="section"><a href="#d0e3394">45.1.2. JavaScript API usage</a></span></dt><dt><span class="section"><a href="#d0e3515">45.1.3. MIME types and unmarshalling.</a></span></dt><dt><span class="section"><a href="#d0e3568">45.1.4. MIME types and marshalling.</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3633">45.2. Using the JavaScript API to build AJAX queries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3638">45.2.1. The REST object</a></span></dt><dt><span class="section"><a href="#d0e3679">45.2.2. The REST.Request class</a></span></dt></dl></dd></dl></div><p>RESTEasy resources can be accessed in JavaScript using AJAX using a 
      proxy API generated by RESTEasy.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3371"/>45.1. Generated JavaScript API</h2></div></div></div><p>
    		RESTEasy can generate a JavaScript API that uses AJAX calls to invoke JAX-RS operations.
    	</p><div class="example"><a id="d0e3376"/><p class="title"><b>Example 45.1. First JAX-RS JavaScript API example</b></p><div class="example-contents"><p>
    			Let's take a simple JAX-RS API:
	    	</p><pre class="programlisting">@Path("orders")
public interface Orders {
 @Path("{id}")
 @GET
 public String getOrder(@PathParam("id") String id){
  return "Hello "+id;
 }
}</pre><p>
				The preceding API would be accessible using the following JavaScript code:
	    	</p><pre class="programlisting">var order = Orders.getOrder({id: 23});</pre></div></div><br class="example-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3387"/>45.1.1. JavaScript API servlet</h3></div></div></div><p>
    			In order to enable the JavaScript API servlet you must configure it in your
    			web.xml file as such:
    		</p><pre class="programlisting">&lt;servlet&gt;
 &lt;servlet-name&gt;RESTEasy JSAPI&lt;/servlet-name&gt;
 &lt;servlet-class&gt;org.jboss.resteasy.jsapi.JSAPIServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
 &lt;servlet-name&gt;RESTEasy JSAPI&lt;/servlet-name&gt;
 &lt;url-pattern&gt;/rest-js&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3394"/>45.1.2. JavaScript API usage</h3></div></div></div><p>
    			Each JAX-RS resource class will generate a JavaScript object of the same name
    			as the declaring class (or interface), which will contain every JAX-RS method
    			as properties.
    		</p><div class="example"><a id="d0e3399"/><p class="title"><b>Example 45.2. Structure of JAX-RS generated JavaScript</b></p><div class="example-contents"><p>For example, if the JAX-RS resource X defines methods Y and Z:
    			</p><pre class="programlisting">@Path("/")
public interface X{
 @GET
 public String Y();
 @PUT
 public void Z(String entity);
}</pre><p>
	    			Then the JavaScript API will define the following functions:
    			</p><pre class="programlisting">var X = {
 Y : function(params){…},
 Z : function(params){…}
};</pre></div></div><br class="example-break"/><p>
				Each JavaScript API method takes an optional object as single
				parameter where each property is a cookie, header, path, query or form parameter as identified
				by their name, or the following special parameters:
    		</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>The following special parameter names are subject to change.</p></div><table xmlns="" id="d0e3415"><caption>Table 45.1. API parameter properties</caption><thead><tr>
						<th>Property name</th>
						<th>Default</th>
						<th>Description</th>
					</tr></thead><tbody><tr>
						<td>$entity</td>
						<td/>
						<td>The entity to send as a PUT, POST request.</td>
					</tr><tr>
						<td>$contentType</td>
						<td>As determined by @Consumes.</td>
						<td>The MIME type of the body entity sent as the Content-Type header.</td>
					</tr><tr>
						<td>$accepts</td>
						<td>Determined by @Provides, defaults to */*.</td>
						<td>The accepted MIME types sent as the Accept header.</td>
					</tr><tr>
						<td>$callback</td>
						<td/>
						<td>
							Set to a function(httpCode, xmlHttpRequest, value) for an asynchronous call. If 
							not present, the call will be synchronous and return the value.
						</td>
					</tr><tr>
						<td>$apiURL</td>
						<td>Determined by container</td>
						<td>Set to the base URI of your JAX-RS endpoint, not including the last slash.</td>
					</tr><tr>
						<td>$username</td>
						<td/>
						<td>If username and password are set, they will be used for credentials for the request.</td>
					</tr><tr>
						<td>$password</td>
						<td/>
						<td>If username and password are set, they will be used for credentials for the request.</td>
					</tr></tbody></table><div class="example"><a id="d0e3504"/><p class="title"><b>Example 45.3. Using the API</b></p><div class="example-contents"><p>Here is an example of JAX-RS API:</p><pre class="programlisting">@Path("foo")
public class Foo{
 @Path("{id}")
 @GET
 public String get(@QueryParam("order") String order, @HeaderParam("X-Foo") String header,
                   @MatrixParam("colour") String colour, @CookieParam("Foo-Cookie") String cookie){
  …
 }
 @POST
 public void post(String text){
 }
}</pre><p>We can use the previous JAX-RS API in JavaScript using the following code:</p><pre class="programlisting">
var text = Foo.get({order: 'desc', 'X-Foo': 'hello',
                    colour: 'blue', 'Foo-Cookie': 123987235444});
Foo.put({$entity: text});</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3515"/>45.1.3. MIME types and unmarshalling.</h3></div></div></div><p>
    			The Accept header sent by any client JavaScript function is controlled by the $accepts parameter, which overrides
    			the @Produces annotation on the JAX-RS endpoint. The returned value however is controlled by the Content-Type header
    			sent in the response as follows:
    		</p><table xmlns="" id="d0e3520"><caption>Table 45.2. Return values by MIME type</caption><thead><tr>
						<th>MIME</th>
						<th>Description</th>
					</tr></thead><tbody><tr>
						<td>text/xml,application/xml,application/*+xml</td>
						<td>
							The response entity is parsed as XML before being returned. The return value is thus a DOM Document.
						</td>
					</tr><tr>
						<td>application/json</td>
						<td>
							The response entity is parsed as JSON before being returned. The return value is thus a JavaScript Object.
						</td>
					</tr><tr>
						<td>Anything else</td>
						<td>The response entity is returned raw.</td>
					</tr></tbody></table><div class="example"><a id="d0e3557"/><p class="title"><b>Example 45.4. Unmarshalling example</b></p><div class="example-contents"><p>
	    			The RESTEasy JavaScript client API can automatically unmarshall JSON and XML:
	    		</p><pre class="programlisting">@Path("orders")
public interface Orders {

 @XmlRootElement
 public static class Order {
  @XmlElement
  private String id;
  
  public Order(){}
  
  public Order(String id){
   this.id = id;
  }
 }

 @Path("{id}/xml")
 @GET
 @Produces("application/xml")
 public Order getOrderXML(@PathParam("id") String id){
  return new Order(id);
 }

 @Path("{id}/json")
 @GET
 @Produces("application/json")
 public Order getOrderJSON(@PathParam("id") String id){
  return new Order(id);
 }
}</pre><p>
					Let us look at what the preceding JAX-RS API would give us on the client side:
	    		</p><pre class="programlisting">// this returns a JSON object
var orderJSON = Orders.getOrderJSON({id: "23"});
orderJSON.id == "23";

// this one returns a DOM Document whose root element is the order, with one child (id)
// whose child is the text node value
var orderXML = Orders.getOrderXML({id: "23"});
orderXML.documentElement.childNodes[0].childNodes[0].nodeValue == "23";</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3568"/>45.1.4. MIME types and marshalling.</h3></div></div></div><p>
    			The Content-Type header sent in the request is controlled by the $contentType parameter which overrides the
    			@Consumes annotation on the JAX-RS endpoint. The value passed as entity body using the $entity parameter is marshalled
    			according to both its type and content type:
    		</p><table xmlns="" id="d0e3573"><caption>Table 45.3. Controlling sent entities</caption><thead><tr>
						<th>Type</th>
						<th>MIME</th>
						<th>Description</th>
					</tr></thead><tbody><tr>
						<td>DOM Element</td>
						<td>Empty or text/xml,application/xml,application/*+xml</td>
						<td>The DOM Element is marshalled to XML before being sent.</td>
					</tr><tr>
						<td>JavaScript Object (JSON)</td>
						<td>Empty or application/json</td>
						<td>The JSON object is marshalled to a JSON string before being sent.</td>
					</tr><tr>
						<td>Anything else</td>
						<td>Anything else</td>
						<td>
							The entity is sent as is.
						</td>
					</tr></tbody></table><div class="example"><a id="d0e3622"/><p class="title"><b>Example 45.5. Marshalling example</b></p><div class="example-contents"><p>
	    			The RESTEasy JavaScript client API can automatically marshall JSON and XML:
	    		</p><pre class="programlisting">@Path("orders")
public interface Orders {

 @XmlRootElement
 public static class Order {
  @XmlElement
  private String id;
  
  public Order(){}
  
  public Order(String id){
   this.id = id;
  }
 }

 @Path("{id}/xml")
 @PUT
 @Consumes("application/xml")
 public void putOrderXML(Order order){
  // store order
 }

 @Path("{id}/json")
 @PUT
 @Consumes("application/json")
 public void putOrderJSON(Order order){
  // store order
 }
}</pre><p>
					Let us look at what the preceding JAX-RS API would give us on the client side:
	    		</p><pre class="programlisting">// this saves a JSON object
Orders.putOrderJSON({$entity: {id: "23"}});

// It is a bit more work with XML
var order = document.createElement("order");
var id = document.createElement("id");
order.appendChild(id);
id.appendChild(document.createTextNode("23"));
Orders.putOrderXML({$entity: order});</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3633"/>45.2. Using the JavaScript API to build AJAX queries</h2></div></div></div><p>
   			The RESTEasy JavaScript API can also be used to manually construct your requests.
   		</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3638"/>45.2.1. The REST object</h3></div></div></div><p>
   				The REST object contains the following read-write properties:
   			</p><table xmlns="" id="d0e3643"><caption>Table 45.4. The REST object</caption><thead><tr>
						<th>Property</th>
						<th>Description</th>
					</tr></thead><tbody><tr>
						<td>apiURL</td>
						<td>
							Set by default to the JAX-RS root URL, used by every JavaScript client API functions when constructing
							the requests.
						</td>
					</tr><tr>
						<td>log</td>
						<td>
							Set to a function(string) in order to receive RESTEasy client API logs. This is useful if you want to
							debug your client API and place the logs where you can see them.
						</td>
					</tr></tbody></table><div class="example"><a id="d0e3672"/><p class="title"><b>Example 45.6. Using the REST object</b></p><div class="example-contents"><p>
	    			The REST object can be used to override RESTEasy JavaScript API client behaviour:
	    		</p><pre class="programlisting">// Change the base URL used by the API:
REST.apiURL = "http://api.service.com";

// log everything in a div element
REST.log = function(text){
 jQuery("#log-div").append(text);
};</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3679"/>45.2.2. The REST.Request class</h3></div></div></div><p>
   				The REST.Request class is used to build custom requests. It has the following members: 
   			</p><table xmlns="" id="d0e3684"><caption>Table 45.5. The REST.Request class</caption><thead><tr>
						<th>Member</th>
						<th>Description</th>
					</tr></thead><tbody><tr>
						<td>execute(callback)</td>
						<td>
							Executes the request with all the information set in the current object. The value is never returned
							but passed to the optional argument callback.
						</td>
					</tr><tr>
						<td>setAccepts(acceptHeader)</td>
						<td>
							Sets the Accept request header. Defaults to */*.
						</td>
					</tr><tr>
						<td>setCredentials(username, password)</td>
						<td>
							Sets the request credentials.
						</td>
					</tr><tr>
						<td>setEntity(entity)</td>
						<td>
							Sets the request entity.
						</td>
					</tr><tr>
						<td>setContentType(contentTypeHeader)</td>
						<td>
							Sets the Content-Type request header.
						</td>
					</tr><tr>
						<td>setURI(uri)</td>
						<td>
							Sets the request URI. This should be an absolute URI.
						</td>
					</tr><tr>
						<td>setMethod(method)</td>
						<td>
							Sets the request method. Defaults to GET.
						</td>
					</tr><tr>
						<td>setAsync(async)</td>
						<td>
							Controls whether the request should be asynchronous. Defaults to true.
						</td>
					</tr><tr>
						<td>addCookie(name, value)</td>
						<td>
							Sets the given cookie in the current document when executing the request.
							Beware that this will be persistent in your browser.
						</td>
					</tr><tr>
						<td>addQueryParameter(name, value)</td>
						<td>
							Adds a query parameter to the URI query part.
						</td>
					</tr><tr>
						<td>addMatrixParameter(name, value)</td>
						<td>
							Adds a matrix parameter (path parameter) to the last path segment of the request URI.
						</td>
					</tr><tr>
						<td>addHeader(name, value)</td>
						<td>
							Adds a request header.
						</td>
					</tr></tbody></table><div class="example"><a id="d0e3793"/><p class="title"><b>Example 45.7. Using the REST.Request class</b></p><div class="example-contents"><p>
	    			The REST.Request class can be used to build custom requests:
	    		</p><pre class="programlisting">var r = new REST.Request();
r.setURI("http://api.service.com/orders/23/json");
r.setMethod("PUT");
r.setContentType("application/json");
r.setEntity({id: "23"});
r.addMatrixParameter("JSESSIONID", "12309812378123");
r.execute(function(status, request, entity){
 log("Response is "+status);
});</pre></div></div><br class="example-break"/></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Maven_and_RESTEasy"/>Chapter 46. Maven and RESTEasy</h2></div></div></div><p>
JBoss's Maven Repository is at:
      http://repository.jboss.org/nexus/content/groups/public/
   </p><p>

      Here's the pom.xml fragment to use. Resteasy is modularized into various components.  Mix and max as you see fit.  Please replace 2.2.1.GA with the current Resteasy version you want to use.
   </p><pre class="programlisting">

&lt;repositories&gt;
   &lt;repository&gt;
      &lt;id&gt;jboss&lt;/id&gt;
      &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public/&lt;/url&gt;
   &lt;/repository&gt;
&lt;/repositories&gt;
&lt;dependencies&gt;
   &lt;!-- core library --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jaxrs&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;

   &lt;!-- optional modules --&gt;

   &lt;!-- JAXB support --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jaxb-provider&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;!-- multipart/form-data and multipart/mixed support --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-multipart-provider&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;!-- Resteasy Server Cache --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-cache-core&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;!-- Ruby YAML support --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-yaml-provider&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;!-- JAXB + Atom support --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-atom-provider&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;!-- Apache Abdera Integration --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;abdera-atom-provider&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;!-- Spring integration --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-spring&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;
   &lt;!-- Guice integration --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-guice&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;

   &lt;!-- Asynchronous HTTP support with JBossWeb --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;async-http-jbossweb&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;

   &lt;!-- Asynchronous HTTP support with Servlet 3.0 (Jetty 7 pre5) --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;async-http-servlet-3.0&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;

   &lt;!-- Asynchronous HTTP support with Tomcat 6 --&gt;
   &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;async-http-tomcat6&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
   &lt;/dependency&gt;

&lt;/dependencies&gt;

</pre><p>
        There is also a pom that can be imported so the versions of the individual modules do not have to be specified. Note that maven 2.0.9 is required for this.
    </p><pre class="programlisting">

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
                &lt;artifactId&gt;resteasy-bom&lt;/artifactId&gt;
                &lt;version&gt;2.2.1.GA&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;

    </pre></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JBoss5"/>Chapter 47. JBoss AS 5.x Integration</h2></div></div></div><p>Resteasy has no special integration with JBoss Application Server so it must be configured and
        installed
        like any other container. There are some issues though. You must make sure that there is not a copy
        of servlet-api-xxx.jar in your WEB-INF/lib directory as this may cause problems. Also, if you are running
        with JDK 6, make sure to filter out the JAXB jars as they come with JDK 6.
    </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="JBoss AS 6"/>Chapter 48. JBoss AS 6 Integration</h2></div></div></div><p>
    RESTEasy is preconfigured and completely integrated with JBoss 6-M4 and higher. You can use it with EJB
    and CDI and you can rely completely on JBoss for scanning for your JAX-RS services and deploying them. All
    you have to provide is your JAX-RS service classes packaged within a WAR either as POJOs, CDI beans,
    or EJBs and provide an empty web.xml file as follows:
</p><p>
    </p><pre class="programlisting">
        
&lt;web-app version="3.0" xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
&lt;/web-app&gt;

    </pre><p>
</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="doc"/>Chapter 49. Documentation Support</h2></div></div></div><p>There's a great javadoc engine that allows you to generate javadocs for JAX-RS and JAXB called<a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.lunatech-labs.com/open-source/jax-doclets">JAX-Doclet</a>. Follow the link for more
        details.
    </p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Migration_from_older_versions"/>Chapter 50. Migration from older versions</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="#22_221">50.1. Migrating from 2.2.0 to 2.2.1</a></span></dt><dt><span class="sect1"><a href="#21_22">50.2. Migrating from 2.1.x to 2.2</a></span></dt><dt><span class="sect1"><a href="#20_21">50.3. Migrating from 2.0.x to 2.1</a></span></dt><dt><span class="sect1"><a href="#Migrating_to_Resteasy_12_20">50.4. Migrating from 1.2.x to 2.0</a></span></dt><dt><span class="sect1"><a href="#migrating_1.2_1.2.1">50.5. Migrating from 1.2.GA to 1.2.1.GA</a></span></dt><dt><span class="sect1"><a href="#Migrating_to_Resteasy_1_1_1_2">50.6. Migrating from 1.1 to 1.2</a></span></dt></dl></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="22_221"/>50.1. Migrating from 2.2.0 to 2.2.1</h2></div></div></div><div class="itemizedlist"><ul><li>
	  Had to upgrade JAXB libs from 2.1.x to 2.2.4 as there was a concurrency bug in JAXB impl.
        </li></ul></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="21_22"/>50.2. Migrating from 2.1.x to 2.2</h2></div></div></div><div class="itemizedlist"><ul><li>
            ClientRequest.getHeaders() always returns a copy. It also converts the values within
            ClientRequest.getHeadersAsObjects() to string. If you
            add values to the map returned by getHeaders() nothing happen. Instead add values to the
            getHeadersAsObjects() map. This allows non-string header objects
            to propagate through the MessageBodyWriter interceptor and ClientExecutor interceptor chains.
        </li></ul></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="20_21"/>50.3. Migrating from 2.0.x to 2.1</h2></div></div></div><div class="itemizedlist"><ul><li>
            Slf4j is no longer the default logging mechanism for resteasy. Resteasy also no longer ships with SLF4J
            libraries. Please read the logging
            section in the Installation and Configuration chapter for more details.
        </li><li>
            The constructor used to instantiate resource and provider classes is now picked based on the requirements of
            the JAX-RS specification.
            Specifically, the public constructor with the most arguments is picked. This behavior varies from previous
            versions where a no-arg
            constructor is preferred.
        </li></ul></div></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Migrating_to_Resteasy_12_20"/>50.4. Migrating from 1.2.x to 2.0</h2></div></div></div><p>

        </p><div class="itemizedlist"><ul><li>
                TJWS has been forked to fix some bugs. The new groupId is org.jboss.resteasy, the artifactId is
                tjws. It will match the resteasy distribution version
            </li><li>
                Please check out the JBoss 6 integration. It makes things alot easier if you are deploying in that
                environment
            </li><li>
                There is a new Filter implementation that is the preferred deployment mechanism. Servlet-based
                deployments are still supported, but it is suggested you use to using a FilterDispatcher. See
                documentation for more details.
            </li><li>
                As per required by the spec List or array injection of empty values will return an empty collection
                or array, not null. I.e.
                (@QueryParam("name") List&lt;String&gt; param) param will be an empty List. Resteasy 1.2.x and
                earlier would return null.
            </li><li>
                We have forked TJWS, the servlet container used for embedded testing into the group
                org.jboss.resteasy, with the artifact id of tjws. You will need
                to remove these dependencies from your maven builds if you are using any part of the resteasy
                embebbable server. TJWS has a number of startup/shutdown
                race conditions we had to fix in order to make unit testing viable.
            </li><li>
                Spring integration compiled against Spring 3.0.3. It may or may not still work with 2.5.6 and lower
            </li></ul></div><p>
    </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="migrating_1.2_1.2.1"/>50.5. Migrating from 1.2.GA to 1.2.1.GA</h2></div></div></div><p>
        Methods @Deprecated within 1.2.GA have been removed. This is in the Client Framework and has to do with all
        references to Apache HTTP Client. You must now create an ClientExecutor if you want to manage your Apache
        HTTP Client
        sessions.
    </p></div><div class="sect1" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="Migrating_to_Resteasy_1_1_1_2"/>50.6. Migrating from 1.1 to 1.2</h2></div></div></div><p>

        </p><div class="itemizedlist"><ul><li>
                The resteasy-maven-import artifact has been renamed to resteasy-bom
            </li><li>
                Jettison and Fastinfoset have been broken out of the resteasy-jaxb-provider maven module. You will
                now need to include resteasy-jettison-provider or resteasy-fastinfoset-provider if you use either
                of these libraries.
            </li><li>
                The constructors for ClientRequest that have a HttpClient parameter (Apache Http Client 3.1 API) are
                now deprecated. They will be removed in the final release of 1.2. You must create a Apache hTTP
                Client Executor and pass it in as a parameter if you want to re-use existing Apache HttpClient
                sessions or do any special configuration. The same is true for the ProxyFactoyr methods.
            </li><li>
                Apache HttpClient 4.0 support is available if you want to use it. I've had some trouble with it so
                it is not the default implementation yet for the client framework.
            </li><li>
                It is no longer required to call RegisterBuiltin.register() to initialize the set of providers. Too
                many users forgot to do this (include myself!). You can turn this off by calling the static method
                ResteasyProviderFactory.setRegisterBuiltinByDefault(false)
            </li><li>
                The Embedded Container's API has changed to use org.jboss.resteasy.spi.ResteasyDeployment. Please
                see embedded documentation for more details.
            </li></ul></div><p>
    </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="REST_BOOKS"/>Chapter 51. Books You Can Read</h2></div></div></div><p>There are a number of great books that you can learn REST and JAX-RS from</p><div class="itemizedlist"><ul><li><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://oreilly.com/catalog/9780596529260/">RESTful Web Services</a> by Leonard Richardson and Sam Ruby.  A great introduction to REST.
</li><li><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://oreilly.com/catalog/9780596158040/">RESTful Java with JAX-RS</a> by Bill Burke.  Overview of REST and detailed explanation of JAX-RS.  
Book examples are distributed with RESTEasy.
</li><li><a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://oreilly.com/catalog/9780596808679/">RESTful Web Services Cookbook</a> by Subbu Allamaraju and Mike Amundsen.  Detailed cookbook on how to design RESTful services.
</li></ul></div></div></div></body></html>